{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Dispatcher = void 0;\nclass Dispatcher {\n  constructor(targets) {\n    this.targets = targets;\n  }\n  callTargets(methodName, ...args) {\n    return this.targets.map(target => {\n      const method = target[methodName];\n      if (typeof method === 'function') {\n        return method.apply(target, args);\n      }\n    });\n  }\n  hasHook(methodName) {\n    return this.targets.some(target => typeof target[methodName] === 'function');\n  }\n  async invokeHook(methodName, ...args) {\n    return Promise.all(this.callTargets(methodName, ...args));\n  }\n  async invokeHooksUntilNonNull(methodName, ...args) {\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (typeof method !== 'function') {\n        continue;\n      }\n      const value = await method.apply(target, args);\n      if (value !== null) {\n        return value;\n      }\n    }\n    return null;\n  }\n  async invokeDidStartHook(methodName, ...args) {\n    const hookReturnValues = await Promise.all(this.callTargets(methodName, ...args));\n    const didEndHooks = hookReturnValues.filter(hook => !!hook);\n    didEndHooks.reverse();\n    return async (...args) => {\n      await Promise.all(didEndHooks.map(hook => hook(...args)));\n    };\n  }\n  invokeSyncDidStartHook(methodName, ...args) {\n    const didEndHooks = [];\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (typeof method === 'function') {\n        const didEndHook = method.apply(target, args);\n        if (didEndHook) {\n          didEndHooks.push(didEndHook);\n        }\n      }\n    }\n    didEndHooks.reverse();\n    return (...args) => {\n      for (const didEndHook of didEndHooks) {\n        didEndHook(...args);\n      }\n    };\n  }\n}\nexports.Dispatcher = Dispatcher;","map":{"version":3,"names":["Dispatcher","constructor","targets","callTargets","methodName","args","map","target","method","apply","hasHook","some","invokeHook","Promise","all","invokeHooksUntilNonNull","value","invokeDidStartHook","hookReturnValues","didEndHooks","filter","hook","reverse","invokeSyncDidStartHook","didEndHook","push","exports"],"sources":["C:\\Users\\Hamza Arrouida\\Desktop\\PROJECTS\\SNRT\\audio-managment-v2 [enhanced]\\node_modules\\apollo-server-core\\src\\utils\\dispatcher.ts"],"sourcesContent":["import type { AnyFunction, AnyFunctionMap } from 'apollo-server-types';\n\ntype Args<F> = F extends (...args: infer A) => any ? A : never;\ntype AsFunction<F> = F extends AnyFunction ? F : never;\ntype StripPromise<T> = T extends Promise<infer U> ? U : never;\n\ntype DidEndHook<TArgs extends any[]> = (...args: TArgs) => void;\ntype AsyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => Promise<void>;\n\nexport class Dispatcher<T extends AnyFunctionMap> {\n  constructor(protected targets: T[]) {}\n\n  private callTargets<TMethodName extends keyof T>(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): ReturnType<AsFunction<T[TMethodName]>>[] {\n    return this.targets.map((target) => {\n      const method = target[methodName];\n      if (typeof method === 'function') {\n        return method.apply(target, args);\n      }\n    });\n  }\n\n  public hasHook(methodName: keyof T): boolean {\n    return this.targets.some(\n      (target) => typeof target[methodName] === 'function',\n    );\n  }\n\n  public async invokeHook<\n    TMethodName extends keyof T,\n    THookReturn extends StripPromise<ReturnType<AsFunction<T[TMethodName]>>>,\n  >(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): Promise<THookReturn[]> {\n    return Promise.all(this.callTargets(methodName, ...args));\n  }\n\n  public async invokeHooksUntilNonNull<TMethodName extends keyof T>(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): Promise<StripPromise<ReturnType<AsFunction<T[TMethodName]>>> | null> {\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (typeof method !== 'function') {\n        continue;\n      }\n      const value = await method.apply(target, args);\n      if (value !== null) {\n        return value;\n      }\n    }\n    return null;\n  }\n\n  public async invokeDidStartHook<\n    TMethodName extends keyof T,\n    TEndHookArgs extends Args<\n      StripPromise<ReturnType<AsFunction<T[TMethodName]>>>\n    >,\n  >(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): Promise<AsyncDidEndHook<TEndHookArgs>> {\n    const hookReturnValues: (AsyncDidEndHook<TEndHookArgs> | void)[] =\n      await Promise.all(this.callTargets(methodName, ...args));\n\n    const didEndHooks = hookReturnValues.filter(\n      (hook): hook is AsyncDidEndHook<TEndHookArgs> => !!hook,\n    );\n    didEndHooks.reverse();\n\n    return async (...args: TEndHookArgs) => {\n      await Promise.all(didEndHooks.map((hook) => hook(...args)));\n    };\n  }\n\n  // Almost all hooks are async, but as a special case, willResolveField is sync\n  // due to performance concerns.\n  public invokeSyncDidStartHook<\n    TMethodName extends keyof T,\n    TEndHookArgs extends Args<ReturnType<AsFunction<T[TMethodName]>>>,\n  >(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): DidEndHook<TEndHookArgs> {\n    const didEndHooks: DidEndHook<TEndHookArgs>[] = [];\n\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (typeof method === 'function') {\n        const didEndHook = method.apply(target, args);\n        if (didEndHook) {\n          didEndHooks.push(didEndHook);\n        }\n      }\n    }\n    didEndHooks.reverse();\n\n    return (...args: TEndHookArgs) => {\n      for (const didEndHook of didEndHooks) {\n        didEndHook(...args);\n      }\n    };\n  }\n}\n"],"mappings":";;;;;;AASA,MAAaA,UAAU;EACrBC,YAAsBC,OAAY;IAAZ,KAAAA,OAAO,GAAPA,OAAO;EAAQ;EAE7BC,WAAWA,CACjBC,UAAuB,EACvB,GAAGC,IAA0B;IAE7B,OAAO,IAAI,CAACH,OAAO,CAACI,GAAG,CAAEC,MAAM,IAAI;MACjC,MAAMC,MAAM,GAAGD,MAAM,CAACH,UAAU,CAAC;MACjC,IAAI,OAAOI,MAAM,KAAK,UAAU,EAAE;QAChC,OAAOA,MAAM,CAACC,KAAK,CAACF,MAAM,EAAEF,IAAI,CAAC;;IAErC,CAAC,CAAC;EACJ;EAEOK,OAAOA,CAACN,UAAmB;IAChC,OAAO,IAAI,CAACF,OAAO,CAACS,IAAI,CACrBJ,MAAM,IAAK,OAAOA,MAAM,CAACH,UAAU,CAAC,KAAK,UAAU,CACrD;EACH;EAEO,MAAMQ,UAAUA,CAIrBR,UAAuB,EACvB,GAAGC,IAA0B;IAE7B,OAAOQ,OAAO,CAACC,GAAG,CAAC,IAAI,CAACX,WAAW,CAACC,UAAU,EAAE,GAAGC,IAAI,CAAC,CAAC;EAC3D;EAEO,MAAMU,uBAAuBA,CAClCX,UAAuB,EACvB,GAAGC,IAA0B;IAE7B,KAAK,MAAME,MAAM,IAAI,IAAI,CAACL,OAAO,EAAE;MACjC,MAAMM,MAAM,GAAGD,MAAM,CAACH,UAAU,CAAC;MACjC,IAAI,OAAOI,MAAM,KAAK,UAAU,EAAE;QAChC;;MAEF,MAAMQ,KAAK,GAAG,MAAMR,MAAM,CAACC,KAAK,CAACF,MAAM,EAAEF,IAAI,CAAC;MAC9C,IAAIW,KAAK,KAAK,IAAI,EAAE;QAClB,OAAOA,KAAK;;;IAGhB,OAAO,IAAI;EACb;EAEO,MAAMC,kBAAkBA,CAM7Bb,UAAuB,EACvB,GAAGC,IAA0B;IAE7B,MAAMa,gBAAgB,GACpB,MAAML,OAAO,CAACC,GAAG,CAAC,IAAI,CAACX,WAAW,CAACC,UAAU,EAAE,GAAGC,IAAI,CAAC,CAAC;IAE1D,MAAMc,WAAW,GAAGD,gBAAgB,CAACE,MAAM,CACxCC,IAAI,IAA4C,CAAC,CAACA,IAAI,CACxD;IACDF,WAAW,CAACG,OAAO,EAAE;IAErB,OAAO,OAAO,GAAGjB,IAAkB,KAAI;MACrC,MAAMQ,OAAO,CAACC,GAAG,CAACK,WAAW,CAACb,GAAG,CAAEe,IAAI,IAAKA,IAAI,CAAC,GAAGhB,IAAI,CAAC,CAAC,CAAC;IAC7D,CAAC;EACH;EAIOkB,sBAAsBA,CAI3BnB,UAAuB,EACvB,GAAGC,IAA0B;IAE7B,MAAMc,WAAW,GAA+B,EAAE;IAElD,KAAK,MAAMZ,MAAM,IAAI,IAAI,CAACL,OAAO,EAAE;MACjC,MAAMM,MAAM,GAAGD,MAAM,CAACH,UAAU,CAAC;MACjC,IAAI,OAAOI,MAAM,KAAK,UAAU,EAAE;QAChC,MAAMgB,UAAU,GAAGhB,MAAM,CAACC,KAAK,CAACF,MAAM,EAAEF,IAAI,CAAC;QAC7C,IAAImB,UAAU,EAAE;UACdL,WAAW,CAACM,IAAI,CAACD,UAAU,CAAC;;;;IAIlCL,WAAW,CAACG,OAAO,EAAE;IAErB,OAAO,CAAC,GAAGjB,IAAkB,KAAI;MAC/B,KAAK,MAAMmB,UAAU,IAAIL,WAAW,EAAE;QACpCK,UAAU,CAAC,GAAGnB,IAAI,CAAC;;IAEvB,CAAC;EACH;;AAjGFqB,OAAA,CAAA1B,UAAA,GAAAA,UAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}