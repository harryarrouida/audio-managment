{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ApolloServerPluginCacheControlDisabled = exports.ApolloServerPluginCacheControl = void 0;\nconst graphql_1 = require(\"graphql\");\nconst cachePolicy_1 = require(\"../../cachePolicy\");\nconst lru_cache_1 = __importDefault(require(\"lru-cache\"));\nfunction ApolloServerPluginCacheControl(options = Object.create(null)) {\n  const typeAnnotationCache = new lru_cache_1.default();\n  const fieldAnnotationCache = new lru_cache_1.default();\n  function memoizedCacheAnnotationFromType(t) {\n    const existing = typeAnnotationCache.get(t);\n    if (existing) {\n      return existing;\n    }\n    const annotation = cacheAnnotationFromType(t);\n    typeAnnotationCache.set(t, annotation);\n    return annotation;\n  }\n  function memoizedCacheAnnotationFromField(field) {\n    const existing = fieldAnnotationCache.get(field);\n    if (existing) {\n      return existing;\n    }\n    const annotation = cacheAnnotationFromField(field);\n    fieldAnnotationCache.set(field, annotation);\n    return annotation;\n  }\n  return {\n    __internal_plugin_id__() {\n      return 'CacheControl';\n    },\n    async serverWillStart({\n      schema\n    }) {\n      typeAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isCompositeType).length;\n      fieldAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isObjectType).flatMap(t => Object.values(t.getFields())).length + Object.values(schema.getTypeMap()).filter(graphql_1.isInterfaceType).flatMap(t => Object.values(t.getFields())).length;\n      return undefined;\n    },\n    async requestDidStart(requestContext) {\n      var _a, _b;\n      const defaultMaxAge = (_a = options.defaultMaxAge) !== null && _a !== void 0 ? _a : 0;\n      const calculateHttpHeaders = (_b = options.calculateHttpHeaders) !== null && _b !== void 0 ? _b : true;\n      const {\n        __testing__cacheHints\n      } = options;\n      return {\n        async executionDidStart() {\n          if (isRestricted(requestContext.overallCachePolicy)) {\n            const fakeFieldPolicy = (0, cachePolicy_1.newCachePolicy)();\n            return {\n              willResolveField({\n                info\n              }) {\n                info.cacheControl = {\n                  setCacheHint: dynamicHint => {\n                    fakeFieldPolicy.replace(dynamicHint);\n                  },\n                  cacheHint: fakeFieldPolicy,\n                  cacheHintFromType: memoizedCacheAnnotationFromType\n                };\n              }\n            };\n          }\n          return {\n            willResolveField({\n              info\n            }) {\n              const fieldPolicy = (0, cachePolicy_1.newCachePolicy)();\n              let inheritMaxAge = false;\n              const targetType = (0, graphql_1.getNamedType)(info.returnType);\n              if ((0, graphql_1.isCompositeType)(targetType)) {\n                const typeAnnotation = memoizedCacheAnnotationFromType(targetType);\n                fieldPolicy.replace(typeAnnotation);\n                inheritMaxAge = !!typeAnnotation.inheritMaxAge;\n              }\n              const fieldAnnotation = memoizedCacheAnnotationFromField(info.parentType.getFields()[info.fieldName]);\n              if (fieldAnnotation.inheritMaxAge && fieldPolicy.maxAge === undefined) {\n                inheritMaxAge = true;\n                if (fieldAnnotation.scope) {\n                  fieldPolicy.replace({\n                    scope: fieldAnnotation.scope\n                  });\n                }\n              } else {\n                fieldPolicy.replace(fieldAnnotation);\n              }\n              info.cacheControl = {\n                setCacheHint: dynamicHint => {\n                  fieldPolicy.replace(dynamicHint);\n                },\n                cacheHint: fieldPolicy,\n                cacheHintFromType: memoizedCacheAnnotationFromType\n              };\n              return () => {\n                if (fieldPolicy.maxAge === undefined && ((0, graphql_1.isCompositeType)(targetType) && !inheritMaxAge || !info.path.prev)) {\n                  fieldPolicy.restrict({\n                    maxAge: defaultMaxAge\n                  });\n                }\n                if (__testing__cacheHints && isRestricted(fieldPolicy)) {\n                  const path = (0, graphql_1.responsePathAsArray)(info.path).join('.');\n                  if (__testing__cacheHints.has(path)) {\n                    throw Error(\"shouldn't happen: addHint should only be called once per path\");\n                  }\n                  __testing__cacheHints.set(path, {\n                    maxAge: fieldPolicy.maxAge,\n                    scope: fieldPolicy.scope\n                  });\n                }\n                requestContext.overallCachePolicy.restrict(fieldPolicy);\n              };\n            }\n          };\n        },\n        async willSendResponse(requestContext) {\n          const {\n            response,\n            overallCachePolicy,\n            requestIsBatched\n          } = requestContext;\n          const policyIfCacheable = overallCachePolicy.policyIfCacheable();\n          if (calculateHttpHeaders && policyIfCacheable && !response.errors && response.http && !requestIsBatched) {\n            response.http.headers.set('Cache-Control', `max-age=${policyIfCacheable.maxAge}, ${policyIfCacheable.scope.toLowerCase()}`);\n          }\n        }\n      };\n    }\n  };\n}\nexports.ApolloServerPluginCacheControl = ApolloServerPluginCacheControl;\nfunction cacheAnnotationFromDirectives(directives) {\n  var _a, _b, _c;\n  if (!directives) return undefined;\n  const cacheControlDirective = directives.find(directive => directive.name.value === 'cacheControl');\n  if (!cacheControlDirective) return undefined;\n  if (!cacheControlDirective.arguments) return undefined;\n  const maxAgeArgument = cacheControlDirective.arguments.find(argument => argument.name.value === 'maxAge');\n  const scopeArgument = cacheControlDirective.arguments.find(argument => argument.name.value === 'scope');\n  const inheritMaxAgeArgument = cacheControlDirective.arguments.find(argument => argument.name.value === 'inheritMaxAge');\n  const scope = ((_a = scopeArgument === null || scopeArgument === void 0 ? void 0 : scopeArgument.value) === null || _a === void 0 ? void 0 : _a.kind) === 'EnumValue' ? scopeArgument.value.value : undefined;\n  if (((_b = inheritMaxAgeArgument === null || inheritMaxAgeArgument === void 0 ? void 0 : inheritMaxAgeArgument.value) === null || _b === void 0 ? void 0 : _b.kind) === 'BooleanValue' && inheritMaxAgeArgument.value.value) {\n    return {\n      inheritMaxAge: true,\n      scope\n    };\n  }\n  return {\n    maxAge: ((_c = maxAgeArgument === null || maxAgeArgument === void 0 ? void 0 : maxAgeArgument.value) === null || _c === void 0 ? void 0 : _c.kind) === 'IntValue' ? parseInt(maxAgeArgument.value.value) : undefined,\n    scope\n  };\n}\nfunction cacheAnnotationFromType(t) {\n  if (t.astNode) {\n    const hint = cacheAnnotationFromDirectives(t.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  if (t.extensionASTNodes) {\n    for (const node of t.extensionASTNodes) {\n      const hint = cacheAnnotationFromDirectives(node.directives);\n      if (hint) {\n        return hint;\n      }\n    }\n  }\n  return {};\n}\nfunction cacheAnnotationFromField(field) {\n  if (field.astNode) {\n    const hint = cacheAnnotationFromDirectives(field.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  return {};\n}\nfunction isRestricted(hint) {\n  return hint.maxAge !== undefined || hint.scope !== undefined;\n}\nfunction ApolloServerPluginCacheControlDisabled() {\n  return {\n    __internal_plugin_id__() {\n      return 'CacheControl';\n    }\n  };\n}\nexports.ApolloServerPluginCacheControlDisabled = ApolloServerPluginCacheControlDisabled;","map":{"version":3,"names":["graphql_1","require","cachePolicy_1","lru_cache_1","__importDefault","ApolloServerPluginCacheControl","options","Object","create","typeAnnotationCache","default","fieldAnnotationCache","memoizedCacheAnnotationFromType","t","existing","get","annotation","cacheAnnotationFromType","set","memoizedCacheAnnotationFromField","field","cacheAnnotationFromField","__internal_plugin_id__","serverWillStart","schema","max","values","getTypeMap","filter","isCompositeType","length","isObjectType","flatMap","getFields","isInterfaceType","undefined","requestDidStart","requestContext","defaultMaxAge","_a","calculateHttpHeaders","_b","__testing__cacheHints","executionDidStart","isRestricted","overallCachePolicy","fakeFieldPolicy","newCachePolicy","willResolveField","info","cacheControl","setCacheHint","dynamicHint","replace","cacheHint","cacheHintFromType","fieldPolicy","inheritMaxAge","targetType","getNamedType","returnType","typeAnnotation","fieldAnnotation","parentType","fieldName","maxAge","scope","path","prev","restrict","responsePathAsArray","join","has","Error","willSendResponse","response","requestIsBatched","policyIfCacheable","errors","http","headers","toLowerCase","exports","cacheAnnotationFromDirectives","directives","cacheControlDirective","find","directive","name","value","arguments","maxAgeArgument","argument","scopeArgument","inheritMaxAgeArgument","kind","_c","parseInt","astNode","hint","extensionASTNodes","node","ApolloServerPluginCacheControlDisabled"],"sources":["C:\\Users\\Hamza Arrouida\\Desktop\\PROJECTS\\SNRT\\audio-managment-v2 [enhanced]\\node_modules\\apollo-server-core\\src\\plugin\\cacheControl\\index.ts"],"sourcesContent":["import type { CacheAnnotation, CacheHint } from 'apollo-server-types';\nimport type { CacheScope } from 'apollo-server-types';\nimport {\n  DirectiveNode,\n  getNamedType,\n  GraphQLCompositeType,\n  GraphQLField,\n  isCompositeType,\n  isInterfaceType,\n  isObjectType,\n  responsePathAsArray,\n} from 'graphql';\nimport { newCachePolicy } from '../../cachePolicy';\nimport type { InternalApolloServerPlugin } from '../../internalPlugin';\nimport LRUCache from 'lru-cache';\n\nexport interface ApolloServerPluginCacheControlOptions {\n  /**\n   * All root fields and fields returning objects or interfaces have this value\n   * for `maxAge` unless they set a cache hint with a non-undefined `maxAge`\n   * using `@cacheControl` or `setCacheHint`. The default is 0, which means \"not\n   * cacheable\". (That is: if you don't set `defaultMaxAge`, then every root\n   * field in your operation and every field with sub-fields must have a cache\n   * hint or the overall operation will not be cacheable.)\n   */\n  defaultMaxAge?: number;\n  /**\n   * Determines whether to set the `Cache-Control` HTTP header on cacheable\n   * responses with no errors. The default is true.\n   */\n  calculateHttpHeaders?: boolean;\n  // For testing only.\n  __testing__cacheHints?: Map<string, CacheHint>;\n}\n\nexport function ApolloServerPluginCacheControl(\n  options: ApolloServerPluginCacheControlOptions = Object.create(null),\n): InternalApolloServerPlugin {\n  const typeAnnotationCache = new LRUCache<\n    GraphQLCompositeType,\n    CacheAnnotation\n  >();\n  const fieldAnnotationCache = new LRUCache<\n    GraphQLField<unknown, unknown>,\n    CacheAnnotation\n  >();\n\n  function memoizedCacheAnnotationFromType(\n    t: GraphQLCompositeType,\n  ): CacheAnnotation {\n    const existing = typeAnnotationCache.get(t);\n    if (existing) {\n      return existing;\n    }\n    const annotation = cacheAnnotationFromType(t);\n    typeAnnotationCache.set(t, annotation);\n    return annotation;\n  }\n\n  function memoizedCacheAnnotationFromField(\n    field: GraphQLField<unknown, unknown>,\n  ): CacheAnnotation {\n    const existing = fieldAnnotationCache.get(field);\n    if (existing) {\n      return existing;\n    }\n    const annotation = cacheAnnotationFromField(field);\n    fieldAnnotationCache.set(field, annotation);\n    return annotation;\n  }\n\n  return {\n    __internal_plugin_id__() {\n      return 'CacheControl';\n    },\n\n    async serverWillStart({ schema }) {\n      // Set the size of the caches to be equal to the number of composite types\n      // and fields in the schema respectively. This generally means that the\n      // cache will always have room for all the cache hints in the active\n      // schema but we won't have a memory leak as schemas are replaced in a\n      // gateway. (Once we're comfortable breaking compatibility with\n      // versions of Gateway older than 0.35.0, we should also run this code\n      // from a schemaDidLoadOrUpdate instead of serverWillStart. Using\n      // schemaDidLoadOrUpdate throws when combined with old gateways.)\n      typeAnnotationCache.max = Object.values(schema.getTypeMap()).filter(\n        isCompositeType,\n      ).length;\n      fieldAnnotationCache.max =\n        Object.values(schema.getTypeMap())\n          .filter(isObjectType)\n          .flatMap((t) => Object.values(t.getFields())).length +\n        Object.values(schema.getTypeMap())\n          .filter(isInterfaceType)\n          .flatMap((t) => Object.values(t.getFields())).length;\n      return undefined;\n    },\n\n    async requestDidStart(requestContext) {\n      const defaultMaxAge: number = options.defaultMaxAge ?? 0;\n      const calculateHttpHeaders = options.calculateHttpHeaders ?? true;\n      const { __testing__cacheHints } = options;\n\n      return {\n        async executionDidStart() {\n          // Did something set the overall cache policy before we've even\n          // started? If so, consider that as an override and don't touch it.\n          // Just put set up fake `info.cacheControl` objects and otherwise\n          // don't track cache policy.\n          //\n          // (This doesn't happen in practice using the core plugins: the main\n          // use case for restricting overallCachePolicy outside of this plugin\n          // is apollo-server-plugin-response-cache, but when it sets the policy\n          // we never get to execution at all.)\n          if (isRestricted(requestContext.overallCachePolicy)) {\n            // This is \"fake\" in the sense that it never actually affects\n            // requestContext.overallCachePolicy.\n            const fakeFieldPolicy = newCachePolicy();\n            return {\n              willResolveField({ info }) {\n                info.cacheControl = {\n                  setCacheHint: (dynamicHint: CacheHint) => {\n                    fakeFieldPolicy.replace(dynamicHint);\n                  },\n                  cacheHint: fakeFieldPolicy,\n                  cacheHintFromType: memoizedCacheAnnotationFromType,\n                };\n              },\n            };\n          }\n\n          return {\n            willResolveField({ info }) {\n              const fieldPolicy = newCachePolicy();\n\n              let inheritMaxAge = false;\n\n              // If this field's resolver returns an object/interface/union\n              // (maybe wrapped in list/non-null), look for hints on that return\n              // type.\n              const targetType = getNamedType(info.returnType);\n              if (isCompositeType(targetType)) {\n                const typeAnnotation =\n                  memoizedCacheAnnotationFromType(targetType);\n                fieldPolicy.replace(typeAnnotation);\n                inheritMaxAge = !!typeAnnotation.inheritMaxAge;\n              }\n\n              // Look for hints on the field itself (on its parent type), taking\n              // precedence over previously calculated hints.\n              const fieldAnnotation = memoizedCacheAnnotationFromField(\n                info.parentType.getFields()[info.fieldName],\n              );\n\n              // Note that specifying `@cacheControl(inheritMaxAge: true)` on a\n              // field whose return type defines a `maxAge` gives precedence to\n              // the type's `maxAge`. (Perhaps this should be some sort of\n              // error.)\n              if (\n                fieldAnnotation.inheritMaxAge &&\n                fieldPolicy.maxAge === undefined\n              ) {\n                inheritMaxAge = true;\n                // Handle `@cacheControl(inheritMaxAge: true, scope: PRIVATE)`.\n                // (We ignore any specified `maxAge`; perhaps it should be some\n                // sort of error.)\n                if (fieldAnnotation.scope) {\n                  fieldPolicy.replace({ scope: fieldAnnotation.scope });\n                }\n              } else {\n                fieldPolicy.replace(fieldAnnotation);\n              }\n\n              info.cacheControl = {\n                setCacheHint: (dynamicHint: CacheHint) => {\n                  fieldPolicy.replace(dynamicHint);\n                },\n                cacheHint: fieldPolicy,\n                cacheHintFromType: memoizedCacheAnnotationFromType,\n              };\n\n              // When the resolver is done, call restrict once. By calling\n              // restrict after the resolver instead of before, we don't need to\n              // \"undo\" the effect on overallCachePolicy of a static hint that\n              // gets refined by a dynamic hint.\n              return () => {\n                // If this field returns a composite type or is a root field and\n                // we haven't seen an explicit maxAge hint, set the maxAge to 0\n                // (uncached) or the default if specified in the constructor.\n                // (Non-object fields by default are assumed to inherit their\n                // cacheability from their parents. But on the other hand, while\n                // root non-object fields can get explicit hints from their\n                // definition on the Query/Mutation object, if that doesn't\n                // exist then there's no parent field that would assign the\n                // default maxAge, so we do it here.)\n                //\n                // You can disable this on a non-root field by writing\n                // `@cacheControl(inheritMaxAge: true)` on it. If you do this,\n                // then its children will be treated like root paths, since\n                // there is no parent maxAge to inherit.\n                //\n                // We do this in the end hook so that dynamic cache control\n                // prevents it from happening (eg,\n                // `info.cacheControl.cacheHint.restrict({maxAge: 60})` should\n                // work rather than doing nothing because we've already set the\n                // max age to the default of 0). This also lets resolvers assume\n                // any hint in `info.cacheControl.cacheHint` was explicitly set.\n                if (\n                  fieldPolicy.maxAge === undefined &&\n                  ((isCompositeType(targetType) && !inheritMaxAge) ||\n                    !info.path.prev)\n                ) {\n                  fieldPolicy.restrict({ maxAge: defaultMaxAge });\n                }\n\n                if (__testing__cacheHints && isRestricted(fieldPolicy)) {\n                  const path = responsePathAsArray(info.path).join('.');\n                  if (__testing__cacheHints.has(path)) {\n                    throw Error(\n                      \"shouldn't happen: addHint should only be called once per path\",\n                    );\n                  }\n                  __testing__cacheHints.set(path, {\n                    maxAge: fieldPolicy.maxAge,\n                    scope: fieldPolicy.scope,\n                  });\n                }\n                requestContext.overallCachePolicy.restrict(fieldPolicy);\n              };\n            },\n          };\n        },\n\n        async willSendResponse(requestContext) {\n          const { response, overallCachePolicy, requestIsBatched } =\n            requestContext;\n\n          const policyIfCacheable = overallCachePolicy.policyIfCacheable();\n\n          // If the feature is enabled, there is a non-trivial cache policy,\n          // there are no errors, we actually can write headers, and the request\n          // is not batched (because we have no way of merging the header across\n          // operations in AS3), write the header.\n          if (\n            calculateHttpHeaders &&\n            policyIfCacheable &&\n            !response.errors &&\n            response.http &&\n            !requestIsBatched\n          ) {\n            response.http.headers.set(\n              'Cache-Control',\n              `max-age=${\n                policyIfCacheable.maxAge\n              }, ${policyIfCacheable.scope.toLowerCase()}`,\n            );\n          }\n        },\n      };\n    },\n  };\n}\n\nfunction cacheAnnotationFromDirectives(\n  directives: ReadonlyArray<DirectiveNode> | undefined,\n): CacheAnnotation | undefined {\n  if (!directives) return undefined;\n\n  const cacheControlDirective = directives.find(\n    (directive) => directive.name.value === 'cacheControl',\n  );\n  if (!cacheControlDirective) return undefined;\n\n  if (!cacheControlDirective.arguments) return undefined;\n\n  const maxAgeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'maxAge',\n  );\n  const scopeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'scope',\n  );\n  const inheritMaxAgeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'inheritMaxAge',\n  );\n\n  const scope =\n    scopeArgument?.value?.kind === 'EnumValue'\n      ? (scopeArgument.value.value as CacheScope)\n      : undefined;\n\n  if (\n    inheritMaxAgeArgument?.value?.kind === 'BooleanValue' &&\n    inheritMaxAgeArgument.value.value\n  ) {\n    // We ignore maxAge if it is also specified.\n    return { inheritMaxAge: true, scope };\n  }\n\n  return {\n    maxAge:\n      maxAgeArgument?.value?.kind === 'IntValue'\n        ? parseInt(maxAgeArgument.value.value)\n        : undefined,\n    scope,\n  };\n}\n\nfunction cacheAnnotationFromType(t: GraphQLCompositeType): CacheAnnotation {\n  if (t.astNode) {\n    const hint = cacheAnnotationFromDirectives(t.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  if (t.extensionASTNodes) {\n    for (const node of t.extensionASTNodes) {\n      const hint = cacheAnnotationFromDirectives(node.directives);\n      if (hint) {\n        return hint;\n      }\n    }\n  }\n  return {};\n}\n\nfunction cacheAnnotationFromField(\n  field: GraphQLField<unknown, unknown>,\n): CacheAnnotation {\n  if (field.astNode) {\n    const hint = cacheAnnotationFromDirectives(field.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  return {};\n}\n\nfunction isRestricted(hint: CacheHint) {\n  return hint.maxAge !== undefined || hint.scope !== undefined;\n}\n\n// This plugin does nothing, but it ensures that ApolloServer won't try\n// to add a default ApolloServerPluginCacheControl.\nexport function ApolloServerPluginCacheControlDisabled(): InternalApolloServerPlugin {\n  return {\n    __internal_plugin_id__() {\n      return 'CacheControl';\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}