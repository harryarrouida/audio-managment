{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultSendOperationsAsTrace = void 0;\nconst lru_cache_1 = __importDefault(require(\"lru-cache\"));\nconst iterateOverTrace_1 = require(\"./iterateOverTrace\");\nconst durationHistogram_1 = require(\"./durationHistogram\");\nfunction defaultSendOperationsAsTrace() {\n  const cache = new lru_cache_1.default({\n    max: Math.pow(2, 20),\n    length: (_val, key) => {\n      return key && Buffer.byteLength(key) || 0;\n    }\n  });\n  return (trace, statsReportKey) => {\n    var _a;\n    const endTimeSeconds = (_a = trace.endTime) === null || _a === void 0 ? void 0 : _a.seconds;\n    if (endTimeSeconds == null) {\n      throw Error('programming error: endTime not set on trace');\n    }\n    const hasErrors = traceHasErrors(trace);\n    const cacheKey = JSON.stringify([statsReportKey, durationHistogram_1.DurationHistogram.durationToBucket(trace.durationNs), Math.floor(endTimeSeconds / 60), hasErrors ? Math.floor(endTimeSeconds / 5) : '']);\n    if (cache.get(cacheKey)) {\n      return false;\n    }\n    cache.set(cacheKey, true);\n    return true;\n  };\n}\nexports.defaultSendOperationsAsTrace = defaultSendOperationsAsTrace;\nfunction traceHasErrors(trace) {\n  let hasErrors = false;\n  function traceNodeStats(node) {\n    var _a, _b;\n    if (((_b = (_a = node.error) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n  (0, iterateOverTrace_1.iterateOverTrace)(trace, traceNodeStats, false);\n  return hasErrors;\n}","map":{"version":3,"names":["lru_cache_1","__importDefault","require","iterateOverTrace_1","durationHistogram_1","defaultSendOperationsAsTrace","cache","default","max","Math","pow","length","_val","key","Buffer","byteLength","trace","statsReportKey","endTimeSeconds","_a","endTime","seconds","Error","hasErrors","traceHasErrors","cacheKey","JSON","stringify","DurationHistogram","durationToBucket","durationNs","floor","get","set","exports","traceNodeStats","node","_b","error","iterateOverTrace"],"sources":["C:\\Users\\Hamza Arrouida\\Desktop\\PROJECTS\\SNRT\\audio-managment-v2 [enhanced]\\node_modules\\apollo-server-core\\src\\plugin\\usageReporting\\defaultSendOperationsAsTrace.ts"],"sourcesContent":["import LRUCache from 'lru-cache';\nimport type { Trace } from 'apollo-reporting-protobuf';\nimport { iterateOverTrace } from './iterateOverTrace';\nimport { DurationHistogram } from './durationHistogram';\n\nexport function defaultSendOperationsAsTrace() {\n  // We keep an LRU cache mapping from a trace key (which consists of the\n  // operation as defined by statsReportKey, the rough duration of the\n  // operation, what minute the operation ended at, etc) to `true` if we've seen\n  // it recently. We actually split this into one cache per minute so we can\n  // throw away a full minute's worth of cache at once; we keep only the last\n  // three minutes\n  const cache = new LRUCache<string, true>({\n    // 3MiB limit, very much approximately since we can't be sure how V8 might\n    // be storing these strings internally. Though this should be enough to\n    // store a fair amount of trace keys.\n\n    // A future version of this might expose some\n    // configuration option to grow the cache, but ideally, we could do that\n    // dynamically based on the resources available to the server, and not add\n    // more configuration surface area. Hopefully the warning message will allow\n    // us to evaluate the need with more validated input from those that receive\n    // it.\n    max: Math.pow(2, 20),\n    length: (_val, key) => {\n      return (key && Buffer.byteLength(key)) || 0;\n    },\n  });\n\n  return (trace: Trace, statsReportKey: string): boolean => {\n    const endTimeSeconds = trace.endTime?.seconds;\n    if (endTimeSeconds == null) {\n      throw Error('programming error: endTime not set on trace');\n    }\n\n    const hasErrors = traceHasErrors(trace);\n    const cacheKey = JSON.stringify([\n      statsReportKey,\n      DurationHistogram.durationToBucket(trace.durationNs),\n      // What minute it started at\n      Math.floor(endTimeSeconds / 60),\n      // If the trace has an error, send one errored trace per 5 second interval\n      // instead of the normal minutely bucket a non-errored trace takes.\n      hasErrors ? Math.floor(endTimeSeconds / 5) : '',\n    ]);\n\n    // If we've already seen something roughly like this, don't send as a trace.\n    if (cache.get(cacheKey)) {\n      return false;\n    }\n\n    cache.set(cacheKey, true);\n    return true;\n  };\n}\n\n// Returns true if any node on the trace has errors. (If this ends up being a\n// hot spot, we can precalculate it in TraceTreeBuilder.)\nfunction traceHasErrors(trace: Trace): boolean {\n  let hasErrors = false;\n\n  function traceNodeStats(node: Trace.INode): boolean {\n    if ((node.error?.length ?? 0) > 0) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n\n  iterateOverTrace(trace, traceNodeStats, false);\n  return hasErrors;\n}\n"],"mappings":";;;;;;;;;;;AAAA,MAAAA,WAAA,GAAAC,eAAA,CAAAC,OAAA;AAEA,MAAAC,kBAAA,GAAAD,OAAA;AACA,MAAAE,mBAAA,GAAAF,OAAA;AAEA,SAAgBG,4BAA4BA,CAAA;EAO1C,MAAMC,KAAK,GAAG,IAAIN,WAAA,CAAAO,OAAQ,CAAe;IAWvCC,GAAG,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;IACpBC,MAAM,EAAEA,CAACC,IAAI,EAAEC,GAAG,KAAI;MACpB,OAAQA,GAAG,IAAIC,MAAM,CAACC,UAAU,CAACF,GAAG,CAAC,IAAK,CAAC;IAC7C;GACD,CAAC;EAEF,OAAO,CAACG,KAAY,EAAEC,cAAsB,KAAa;;IACvD,MAAMC,cAAc,GAAG,CAAAC,EAAA,GAAAH,KAAK,CAACI,OAAO,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,OAAO;IAC7C,IAAIH,cAAc,IAAI,IAAI,EAAE;MAC1B,MAAMI,KAAK,CAAC,6CAA6C,CAAC;;IAG5D,MAAMC,SAAS,GAAGC,cAAc,CAACR,KAAK,CAAC;IACvC,MAAMS,QAAQ,GAAGC,IAAI,CAACC,SAAS,CAAC,CAC9BV,cAAc,EACdb,mBAAA,CAAAwB,iBAAiB,CAACC,gBAAgB,CAACb,KAAK,CAACc,UAAU,CAAC,EAEpDrB,IAAI,CAACsB,KAAK,CAACb,cAAc,GAAG,EAAE,CAAC,EAG/BK,SAAS,GAAGd,IAAI,CAACsB,KAAK,CAACb,cAAc,GAAG,CAAC,CAAC,GAAG,EAAE,CAChD,CAAC;IAGF,IAAIZ,KAAK,CAAC0B,GAAG,CAACP,QAAQ,CAAC,EAAE;MACvB,OAAO,KAAK;;IAGdnB,KAAK,CAAC2B,GAAG,CAACR,QAAQ,EAAE,IAAI,CAAC;IACzB,OAAO,IAAI;EACb,CAAC;AACH;AAjDAS,OAAA,CAAA7B,4BAAA,GAAAA,4BAAA;AAqDA,SAASmB,cAAcA,CAACR,KAAY;EAClC,IAAIO,SAAS,GAAG,KAAK;EAErB,SAASY,cAAcA,CAACC,IAAiB;;IACvC,IAAI,CAAC,CAAAC,EAAA,IAAAlB,EAAA,GAAAiB,IAAI,CAACE,KAAK,cAAAnB,EAAA,uBAAAA,EAAA,CAAER,MAAM,cAAA0B,EAAA,cAAAA,EAAA,GAAI,CAAC,IAAI,CAAC,EAAE;MACjCd,SAAS,GAAG,IAAI;;IAElB,OAAOA,SAAS;EAClB;EAEA,IAAApB,kBAAA,CAAAoC,gBAAgB,EAACvB,KAAK,EAAEmB,cAAc,EAAE,KAAK,CAAC;EAC9C,OAAOZ,SAAS;AAClB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}