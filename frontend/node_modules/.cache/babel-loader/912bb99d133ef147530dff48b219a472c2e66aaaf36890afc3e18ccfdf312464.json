{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cloneObject = exports.processHTTPRequest = exports.runHttpQuery = exports.throwHttpGraphQLError = exports.isHttpQueryError = exports.HttpQueryError = void 0;\nconst apollo_server_env_1 = require(\"apollo-server-env\");\nconst apollo_server_errors_1 = require(\"apollo-server-errors\");\nconst whatwg_mimetype_1 = __importDefault(require(\"whatwg-mimetype\"));\nconst cachePolicy_1 = require(\"./cachePolicy\");\nconst graphqlOptions_1 = require(\"./graphqlOptions\");\nconst requestPipeline_1 = require(\"./requestPipeline\");\nclass HttpQueryError extends Error {\n  constructor(statusCode, message, isGraphQLError = false, headers) {\n    super(message);\n    this.name = 'HttpQueryError';\n    this.statusCode = statusCode;\n    this.isGraphQLError = isGraphQLError;\n    this.headers = headers;\n  }\n}\nexports.HttpQueryError = HttpQueryError;\nfunction isHttpQueryError(e) {\n  return (e === null || e === void 0 ? void 0 : e.name) === 'HttpQueryError';\n}\nexports.isHttpQueryError = isHttpQueryError;\nfunction throwHttpGraphQLError(statusCode, errors, options, extensions, headers) {\n  const allHeaders = {\n    'Content-Type': 'application/json'\n  };\n  if (headers) {\n    for (const [name, value] of headers) {\n      allHeaders[name] = value;\n    }\n  }\n  const result = {\n    errors: options ? (0, apollo_server_errors_1.formatApolloErrors)(errors, {\n      debug: options.debug,\n      formatter: options.formatError\n    }) : errors\n  };\n  if (extensions) {\n    result.extensions = extensions;\n  }\n  throw new HttpQueryError(statusCode, prettyJSONStringify(result), true, allHeaders);\n}\nexports.throwHttpGraphQLError = throwHttpGraphQLError;\nconst NODE_ENV = (_a = process.env.NODE_ENV) !== null && _a !== void 0 ? _a : '';\nconst NON_PREFLIGHTED_CONTENT_TYPES = ['application/x-www-form-urlencoded', 'multipart/form-data', 'text/plain'];\nfunction preventCsrf(headers, csrfPreventionRequestHeaders) {\n  const contentType = headers.get('content-type');\n  if (contentType !== null) {\n    const contentTypeParsed = whatwg_mimetype_1.default.parse(contentType);\n    if (contentTypeParsed === null) {\n      return;\n    }\n    if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {\n      return;\n    }\n  }\n  if (csrfPreventionRequestHeaders.some(header => {\n    const value = headers.get(header);\n    return value !== null && value.length > 0;\n  })) {\n    return;\n  }\n  throw new HttpQueryError(400, `This operation has been blocked as a potential Cross-Site Request Forgery ` + `(CSRF). Please either specify a 'content-type' header (with a type that ` + `is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(', ')}) or provide ` + `a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(', ')}\\n`);\n}\nasync function runHttpQuery(handlerArguments, request, csrfPreventionRequestHeaders) {\n  function debugFromNodeEnv(nodeEnv = NODE_ENV) {\n    return nodeEnv !== 'production' && nodeEnv !== 'test';\n  }\n  if (csrfPreventionRequestHeaders) {\n    preventCsrf(request.request.headers, csrfPreventionRequestHeaders);\n  }\n  let options;\n  try {\n    options = await (0, graphqlOptions_1.resolveGraphqlOptions)(request.options, ...handlerArguments);\n  } catch (e) {\n    return throwHttpGraphQLError(500, [e], {\n      debug: debugFromNodeEnv()\n    });\n  }\n  if (options.debug === undefined) {\n    options.debug = debugFromNodeEnv(options.nodeEnv);\n  }\n  if (typeof options.context === 'function') {\n    try {\n      options.context();\n    } catch (e) {\n      e.message = `Context creation failed: ${e.message}`;\n      if (e.extensions && e.extensions.code && e.extensions.code !== 'INTERNAL_SERVER_ERROR') {\n        return throwHttpGraphQLError(400, [e], options);\n      } else {\n        return throwHttpGraphQLError(500, [e], options);\n      }\n    }\n  }\n  const config = {\n    schema: options.schema,\n    schemaHash: options.schemaHash,\n    logger: options.logger,\n    rootValue: options.rootValue,\n    context: options.context || {},\n    validationRules: options.validationRules,\n    executor: options.executor,\n    fieldResolver: options.fieldResolver,\n    cache: options.cache,\n    dataSources: options.dataSources,\n    dangerouslyDisableValidation: options.dangerouslyDisableValidation,\n    documentStore: options.documentStore,\n    persistedQueries: options.persistedQueries,\n    formatError: options.formatError,\n    formatResponse: options.formatResponse,\n    debug: options.debug,\n    plugins: options.plugins || [],\n    allowBatchedHttpRequests: options.allowBatchedHttpRequests\n  };\n  return processHTTPRequest(config, request);\n}\nexports.runHttpQuery = runHttpQuery;\nasync function processHTTPRequest(options, httpRequest) {\n  var _a, _b;\n  let requestPayload;\n  switch (httpRequest.method) {\n    case 'POST':\n      if (!httpRequest.query || typeof httpRequest.query === 'string' || Buffer.isBuffer(httpRequest.query) || Object.keys(httpRequest.query).length === 0) {\n        throw new HttpQueryError(400, 'POST body missing, invalid Content-Type, or JSON object has no keys.');\n      }\n      requestPayload = httpRequest.query;\n      break;\n    case 'GET':\n      if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {\n        throw new HttpQueryError(400, 'GET query missing.');\n      }\n      requestPayload = httpRequest.query;\n      break;\n    default:\n      throw new HttpQueryError(405, 'Apollo Server supports only GET/POST requests.', false, {\n        Allow: 'GET, POST'\n      });\n  }\n  options = {\n    ...options,\n    plugins: [checkOperationPlugin, ...options.plugins]\n  };\n  function buildRequestContext(request, requestIsBatched) {\n    const context = cloneObject(options.context);\n    return {\n      logger: options.logger || console,\n      schema: options.schema,\n      schemaHash: options.schemaHash,\n      request,\n      response: {\n        http: {\n          headers: new apollo_server_env_1.Headers()\n        }\n      },\n      context,\n      cache: options.cache,\n      debug: options.debug,\n      metrics: {},\n      overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),\n      requestIsBatched\n    };\n  }\n  const responseInit = {\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  };\n  let body;\n  try {\n    if (Array.isArray(requestPayload)) {\n      if (options.allowBatchedHttpRequests === false) {\n        return throwHttpGraphQLError(400, [new Error('Operation batching disabled.')], options);\n      }\n      const requests = requestPayload.map(requestParams => parseGraphQLRequest(httpRequest.request, requestParams));\n      const responses = await Promise.all(requests.map(async request => {\n        try {\n          const requestContext = buildRequestContext(request, true);\n          const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);\n          if (response.http) {\n            for (const [name, value] of response.http.headers) {\n              responseInit.headers[name] = value;\n            }\n            if (response.http.status) {\n              responseInit.status = response.http.status;\n            }\n          }\n          return response;\n        } catch (error) {\n          return {\n            errors: (0, apollo_server_errors_1.formatApolloErrors)([error], options)\n          };\n        }\n      }));\n      body = prettyJSONStringify(responses.map(serializeGraphQLResponse));\n    } else {\n      const request = parseGraphQLRequest(httpRequest.request, requestPayload);\n      const requestContext = buildRequestContext(request, false);\n      const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);\n      if (response.errors && typeof response.data === 'undefined') {\n        return throwHttpGraphQLError(((_a = response.http) === null || _a === void 0 ? void 0 : _a.status) || 400, response.errors, undefined, response.extensions, (_b = response.http) === null || _b === void 0 ? void 0 : _b.headers);\n      }\n      if (response.http) {\n        for (const [name, value] of response.http.headers) {\n          responseInit.headers[name] = value;\n        }\n        if (response.http.status) {\n          responseInit.status = response.http.status;\n        }\n      }\n      body = prettyJSONStringify(serializeGraphQLResponse(response));\n    }\n  } catch (error) {\n    if (error instanceof HttpQueryError) {\n      throw error;\n    }\n    return throwHttpGraphQLError(500, [error], options);\n  }\n  responseInit.headers['Content-Length'] = Buffer.byteLength(body, 'utf8').toString();\n  return {\n    graphqlResponse: body,\n    responseInit\n  };\n}\nexports.processHTTPRequest = processHTTPRequest;\nfunction parseGraphQLRequest(httpRequest, requestParams) {\n  let queryString = requestParams.query;\n  let extensions = requestParams.extensions;\n  if (typeof extensions === 'string' && extensions !== '') {\n    try {\n      extensions = JSON.parse(extensions);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Extensions are invalid JSON.');\n    }\n  }\n  if (queryString && typeof queryString !== 'string') {\n    if (queryString.kind === 'Document') {\n      throw new HttpQueryError(400, \"GraphQL queries must be strings. It looks like you're sending the \" + 'internal graphql-js representation of a parsed query in your ' + 'request instead of a request in the GraphQL query language. You ' + 'can convert an AST to a string using the `print` function from ' + '`graphql`, or use a client like `apollo-client` which converts ' + 'the internal representation to a string for you.');\n    } else {\n      throw new HttpQueryError(400, 'GraphQL queries must be strings.');\n    }\n  }\n  const operationName = requestParams.operationName;\n  let variables = requestParams.variables;\n  if (typeof variables === 'string' && variables !== '') {\n    try {\n      variables = JSON.parse(variables);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Variables are invalid JSON.');\n    }\n  }\n  return {\n    query: queryString,\n    operationName,\n    variables,\n    extensions,\n    http: httpRequest\n  };\n}\nconst checkOperationPlugin = {\n  async requestDidStart() {\n    return {\n      async didResolveOperation({\n        request,\n        operation\n      }) {\n        if (!request.http) return;\n        if (request.http.method === 'GET' && operation.operation !== 'query') {\n          throw new HttpQueryError(405, `GET supports only query operation`, false, {\n            Allow: 'POST'\n          });\n        }\n      }\n    };\n  }\n};\nfunction serializeGraphQLResponse(response) {\n  return {\n    errors: response.errors,\n    data: response.data,\n    extensions: response.extensions\n  };\n}\nfunction prettyJSONStringify(value) {\n  return JSON.stringify(value) + '\\n';\n}\nfunction cloneObject(object) {\n  return Object.assign(Object.create(Object.getPrototypeOf(object)), object);\n}\nexports.cloneObject = cloneObject;","map":{"version":3,"names":["apollo_server_env_1","require","apollo_server_errors_1","whatwg_mimetype_1","__importDefault","cachePolicy_1","graphqlOptions_1","requestPipeline_1","HttpQueryError","Error","constructor","statusCode","message","isGraphQLError","headers","name","exports","isHttpQueryError","e","throwHttpGraphQLError","errors","options","extensions","allHeaders","value","result","formatApolloErrors","debug","formatter","formatError","prettyJSONStringify","NODE_ENV","_a","process","env","NON_PREFLIGHTED_CONTENT_TYPES","preventCsrf","csrfPreventionRequestHeaders","contentType","get","contentTypeParsed","default","parse","includes","essence","some","header","length","join","runHttpQuery","handlerArguments","request","debugFromNodeEnv","nodeEnv","resolveGraphqlOptions","undefined","context","code","config","schema","schemaHash","logger","rootValue","validationRules","executor","fieldResolver","cache","dataSources","dangerouslyDisableValidation","documentStore","persistedQueries","formatResponse","plugins","allowBatchedHttpRequests","processHTTPRequest","httpRequest","requestPayload","method","query","Buffer","isBuffer","Object","keys","Allow","checkOperationPlugin","buildRequestContext","requestIsBatched","cloneObject","console","response","http","Headers","metrics","overallCachePolicy","newCachePolicy","responseInit","body","Array","isArray","requests","map","requestParams","parseGraphQLRequest","responses","Promise","all","requestContext","processGraphQLRequest","status","error","serializeGraphQLResponse","data","_b","byteLength","toString","graphqlResponse","queryString","JSON","kind","operationName","variables","requestDidStart","didResolveOperation","operation","stringify","object","assign","create","getPrototypeOf"],"sources":["C:\\Users\\Hamza Arrouida\\Desktop\\PROJECTS\\SNRT\\audio-managment-v2 [enhanced]\\node_modules\\apollo-server-core\\src\\runHttpQuery.ts"],"sourcesContent":["import { Headers, Request } from 'apollo-server-env';\nimport { ApolloError, formatApolloErrors } from 'apollo-server-errors';\nimport type { ApolloServerPlugin } from 'apollo-server-plugin-base';\nimport type {\n  BaseContext,\n  GraphQLExecutionResult,\n  ValueOrPromise,\n  WithRequired,\n} from 'apollo-server-types';\nimport MIMEType from 'whatwg-mimetype';\nimport { newCachePolicy } from './cachePolicy';\nimport {\n  default as GraphQLOptions,\n  resolveGraphqlOptions,\n} from './graphqlOptions';\nimport {\n  GraphQLRequest,\n  GraphQLRequestContext,\n  GraphQLResponse,\n  processGraphQLRequest,\n} from './requestPipeline';\n\nexport interface HttpQueryRequest {\n  method: string;\n  // query is either the POST body or the GET query string map.  In the GET\n  // case, all values are strings and need to be parsed as JSON; in the POST\n  // case they should already be parsed. query has keys like 'query' (whose\n  // value should always be a string), 'variables', 'operationName',\n  // 'extensions', etc.\n  query: Record<string, any> | Array<Record<string, any>>;\n  options:\n    | GraphQLOptions\n    | ((...args: Array<any>) => ValueOrPromise<GraphQLOptions>);\n  request: Pick<Request, 'url' | 'method' | 'headers'>;\n}\n\ninterface ApolloServerHttpResponse {\n  headers?: Record<string, string>;\n  status?: number;\n  // ResponseInit contains the follow, which we do not use\n  // statusText?: string;\n}\n\ninterface HttpQueryResponse {\n  // TODO: This isn't actually an individual GraphQL response, but the body\n  // of the HTTP response, which could contain multiple GraphQL responses\n  // when using batching.\n  graphqlResponse: string;\n  responseInit: ApolloServerHttpResponse;\n}\n\nexport class HttpQueryError extends Error {\n  public statusCode: number;\n  public isGraphQLError: boolean;\n  public headers?: { [key: string]: string };\n\n  constructor(\n    statusCode: number,\n    message: string,\n    isGraphQLError: boolean = false,\n    headers?: { [key: string]: string },\n  ) {\n    super(message);\n    this.name = 'HttpQueryError';\n    this.statusCode = statusCode;\n    this.isGraphQLError = isGraphQLError;\n    this.headers = headers;\n  }\n}\n\nexport function isHttpQueryError(e: unknown): e is HttpQueryError {\n  return (e as any)?.name === 'HttpQueryError';\n}\n\n/**\n * If options is specified, then the errors array will be formatted\n */\nexport function throwHttpGraphQLError<E extends Error>(\n  statusCode: number,\n  errors: Array<E>,\n  options?: Pick<GraphQLOptions, 'debug' | 'formatError'>,\n  extensions?: GraphQLExecutionResult['extensions'],\n  headers?: Headers,\n): never {\n  const allHeaders: Record<string, string> = {\n    'Content-Type': 'application/json',\n  };\n  if (headers) {\n    for (const [name, value] of headers) {\n      allHeaders[name] = value;\n    }\n  }\n\n  type Result = Pick<GraphQLExecutionResult, 'extensions'> & {\n    errors: E[] | ApolloError[];\n  };\n\n  const result: Result = {\n    errors: options\n      ? formatApolloErrors(errors, {\n          debug: options.debug,\n          formatter: options.formatError,\n        })\n      : errors,\n  };\n\n  if (extensions) {\n    result.extensions = extensions;\n  }\n\n  throw new HttpQueryError(\n    statusCode,\n    prettyJSONStringify(result),\n    true,\n    allHeaders,\n  );\n}\n\nconst NODE_ENV = process.env.NODE_ENV ?? '';\n\n// See https://fetch.spec.whatwg.org/#cors-safelisted-request-header\nconst NON_PREFLIGHTED_CONTENT_TYPES = [\n  'application/x-www-form-urlencoded',\n  'multipart/form-data',\n  'text/plain',\n];\n\n// We don't want random websites to be able to execute actual GraphQL operations\n// from a user's browser unless our CORS policy supports it. It's not good\n// enough just to ensure that the browser can't read the response from the\n// operation; we also want to prevent CSRF, where the attacker can cause side\n// effects with an operation or can measure the timing of a read operation. Our\n// goal is to ensure that we don't run the context function or execute the\n// GraphQL operation until the browser has evaluated the CORS policy, which\n// means we want all operations to be pre-flighted. We can do that by only\n// processing operations that have at least one header set that appears to be\n// manually set by the JS code rather than by the browser automatically.\n//\n// POST requests generally have a content-type `application/json`, which is\n// sufficient to trigger preflighting. So we take extra care with requests that\n// specify no content-type or that specify one of the three non-preflighted\n// content types. For those operations, we require (if this feature is enabled)\n// one of a set of specific headers to be set. By ensuring that every operation\n// either has a custom content-type or sets one of these headers, we know we\n// won't execute operations at the request of origins who our CORS policy will\n// block.\nfunction preventCsrf(headers: Headers, csrfPreventionRequestHeaders: string[]) {\n  const contentType = headers.get('content-type');\n\n  // We have to worry about CSRF if it looks like this may have been a\n  // non-preflighted request. If we see a content-type header that is not one of\n  // the three CORS-safelisted MIME types (see\n  // https://fetch.spec.whatwg.org/#cors-safelisted-request-header) then we know\n  // it was preflighted and we don't have to worry.\n  if (contentType !== null) {\n    const contentTypeParsed = MIMEType.parse(contentType);\n    if (contentTypeParsed === null) {\n      // If we got null, then parsing the content-type failed... which is\n      // actually *ok* because that would lead to a preflight. (For example, the\n      // header is empty, or doesn't have a slash, or has bad characters.) The\n      // scary CSRF case is only if there's *not* an error. So it is actually\n      // fine for us to just `return` here. (That said, it would also be\n      // reasonable to reject such requests with provided yet unparsable\n      // Content-Type here.)\n      return;\n    }\n    if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {\n      // We managed to parse a MIME type that was not one of the\n      // CORS-safelisted ones. (Probably application/json!) That means that if\n      // the client is a browser, the browser must have applied CORS\n      // preflighting and we don't have to worry about CSRF.\n      return;\n    }\n  }\n\n  // Either there was no content-type, or the content-type parsed properly as\n  // one of the three CORS-safelisted values. Let's look for another header that\n  // (if this was a browser) must have been set by the user's code and would\n  // have caused a preflight.\n  if (\n    csrfPreventionRequestHeaders.some((header) => {\n      const value = headers.get(header);\n      return value !== null && value.length > 0;\n    })\n  ) {\n    return;\n  }\n\n  throw new HttpQueryError(\n    400,\n    `This operation has been blocked as a potential Cross-Site Request Forgery ` +\n      `(CSRF). Please either specify a 'content-type' header (with a type that ` +\n      `is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(', ')}) or provide ` +\n      `a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(\n        ', ',\n      )}\\n`,\n  );\n}\n\nexport async function runHttpQuery(\n  handlerArguments: Array<any>,\n  request: HttpQueryRequest,\n  csrfPreventionRequestHeaders?: string[] | null,\n): Promise<HttpQueryResponse> {\n  function debugFromNodeEnv(nodeEnv: string = NODE_ENV) {\n    return nodeEnv !== 'production' && nodeEnv !== 'test';\n  }\n\n  // If enabled, check to ensure that this request was preflighted before doing\n  // anything real (such as running the context function).\n  if (csrfPreventionRequestHeaders) {\n    preventCsrf(request.request.headers, csrfPreventionRequestHeaders);\n  }\n\n  let options: GraphQLOptions;\n  try {\n    options = await resolveGraphqlOptions(request.options, ...handlerArguments);\n  } catch (e) {\n    // The options can be generated asynchronously, so we don't have access to\n    // the normal options provided by the user, such as: formatError,\n    // debug. Therefore, we need to do some unnatural things, such\n    // as use NODE_ENV to determine the debug settings. Please note that this\n    // will not be sensitive to any runtime changes made to NODE_ENV.\n    return throwHttpGraphQLError(500, [e as Error], {\n      debug: debugFromNodeEnv(),\n    });\n  }\n\n  if (options.debug === undefined) {\n    options.debug = debugFromNodeEnv(options.nodeEnv);\n  }\n\n  // TODO: Errors thrown while resolving the context in\n  // ApolloServer#graphQLServerOptions are currently converted to\n  // a throwing function, which we invoke here to rethrow an HTTP error.\n  // When we refactor the integration between ApolloServer, the middleware and\n  // runHttpQuery, we should pass the original context function through,\n  // so we can resolve it on every GraphQL request (as opposed to once per HTTP\n  // request, which could be a batch).\n  if (typeof options.context === 'function') {\n    try {\n      (options.context as () => never)();\n    } catch (e: any) {\n      // XXX `any` isn't ideal, but this is the easiest thing for now, without\n      // introducing a strong `instanceof GraphQLError` requirement.\n      e.message = `Context creation failed: ${e.message}`;\n      // For errors that are not internal, such as authentication, we\n      // should provide a 400 response\n      if (\n        e.extensions &&\n        e.extensions.code &&\n        e.extensions.code !== 'INTERNAL_SERVER_ERROR'\n      ) {\n        return throwHttpGraphQLError(400, [e], options);\n      } else {\n        return throwHttpGraphQLError(500, [e], options);\n      }\n    }\n  }\n\n  const config = {\n    schema: options.schema,\n    schemaHash: options.schemaHash,\n    logger: options.logger,\n    rootValue: options.rootValue,\n    context: options.context || {},\n    validationRules: options.validationRules,\n    executor: options.executor,\n    fieldResolver: options.fieldResolver,\n\n    // TODO: Use proper option types to ensure this\n    // The cache is guaranteed to be initialized in ApolloServer, and\n    // cacheControl defaults will also have been set if a boolean argument is\n    // passed in.\n    cache: options.cache!,\n    dataSources: options.dataSources,\n    dangerouslyDisableValidation: options.dangerouslyDisableValidation,\n    documentStore: options.documentStore,\n\n    persistedQueries: options.persistedQueries,\n\n    formatError: options.formatError,\n    formatResponse: options.formatResponse,\n\n    debug: options.debug,\n\n    plugins: options.plugins || [],\n\n    allowBatchedHttpRequests: options.allowBatchedHttpRequests,\n  };\n\n  return processHTTPRequest(config, request);\n}\n\nexport async function processHTTPRequest<TContext extends BaseContext>(\n  options: WithRequired<GraphQLOptions<TContext>, 'cache' | 'plugins'> & {\n    context: TContext;\n  },\n  httpRequest: HttpQueryRequest,\n): Promise<HttpQueryResponse> {\n  let requestPayload;\n\n  switch (httpRequest.method) {\n    case 'POST':\n      if (\n        !httpRequest.query ||\n        typeof httpRequest.query === 'string' ||\n        Buffer.isBuffer(httpRequest.query) ||\n        Object.keys(httpRequest.query).length === 0\n      ) {\n        throw new HttpQueryError(\n          400,\n          'POST body missing, invalid Content-Type, or JSON object has no keys.',\n        );\n      }\n\n      requestPayload = httpRequest.query;\n      break;\n    case 'GET':\n      if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {\n        throw new HttpQueryError(400, 'GET query missing.');\n      }\n\n      requestPayload = httpRequest.query;\n      break;\n\n    default:\n      throw new HttpQueryError(\n        405,\n        'Apollo Server supports only GET/POST requests.',\n        false,\n        {\n          Allow: 'GET, POST',\n        },\n      );\n  }\n\n  // Create a local copy of `options`, based on global options, but maintaining\n  // that appropriate plugins are in place.\n  options = {\n    ...options,\n    plugins: [checkOperationPlugin, ...options.plugins],\n  };\n\n  function buildRequestContext(\n    request: GraphQLRequest,\n    requestIsBatched: boolean,\n  ): GraphQLRequestContext<TContext> {\n    // TODO: We currently shallow clone the context for every request,\n    // but that's unlikely to be what people want.\n    // We allow passing in a function for `context` to ApolloServer,\n    // but this only runs once for a batched request (because this is resolved\n    // in ApolloServer#graphQLServerOptions, before runHttpQuery is invoked).\n    // NOTE: THIS IS DUPLICATED IN ApolloServerBase.prototype.executeOperation.\n    const context = cloneObject(options.context);\n    return {\n      // While `logger` is guaranteed by internal Apollo Server usage of\n      // this `processHTTPRequest` method, this method has been publicly\n      // exported since perhaps as far back as Apollo Server 1.x.  Therefore,\n      // for compatibility reasons, we'll default to `console`.\n      logger: options.logger || console,\n      schema: options.schema,\n      schemaHash: options.schemaHash,\n      request,\n      response: {\n        http: {\n          headers: new Headers(),\n        },\n      },\n      context,\n      cache: options.cache,\n      debug: options.debug,\n      metrics: {},\n      overallCachePolicy: newCachePolicy(),\n      requestIsBatched,\n    };\n  }\n\n  const responseInit: ApolloServerHttpResponse = {\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  };\n\n  let body: string;\n\n  try {\n    if (Array.isArray(requestPayload)) {\n      if (options.allowBatchedHttpRequests === false) {\n        return throwHttpGraphQLError(\n          400,\n          [new Error('Operation batching disabled.')],\n          options,\n        );\n      }\n\n      // We're processing a batch request\n      const requests = requestPayload.map((requestParams) =>\n        parseGraphQLRequest(httpRequest.request, requestParams),\n      );\n\n      const responses = await Promise.all(\n        requests.map(async (request) => {\n          try {\n            const requestContext = buildRequestContext(request, true);\n            const response = await processGraphQLRequest(\n              options,\n              requestContext,\n            );\n            if (response.http) {\n              for (const [name, value] of response.http.headers) {\n                responseInit.headers![name] = value;\n              }\n\n              if (response.http.status) {\n                responseInit.status = response.http.status;\n              }\n            }\n            return response;\n          } catch (error) {\n            // A batch can contain another query that returns data,\n            // so we don't error out the entire request with an HttpError\n            return {\n              errors: formatApolloErrors([error as Error], options),\n            };\n          }\n        }),\n      );\n\n      body = prettyJSONStringify(responses.map(serializeGraphQLResponse));\n    } else {\n      // We're processing a normal request\n      const request = parseGraphQLRequest(httpRequest.request, requestPayload);\n\n      const requestContext = buildRequestContext(request, false);\n\n      const response = await processGraphQLRequest(options, requestContext);\n\n      // This code is run on parse/validation errors and any other error that\n      // doesn't reach GraphQL execution\n      if (response.errors && typeof response.data === 'undefined') {\n        // don't include options, since the errors have already been formatted\n        return throwHttpGraphQLError(\n          response.http?.status || 400,\n          response.errors as any,\n          undefined,\n          response.extensions,\n          response.http?.headers,\n        );\n      }\n\n      if (response.http) {\n        for (const [name, value] of response.http.headers) {\n          responseInit.headers![name] = value;\n        }\n\n        if (response.http.status) {\n          responseInit.status = response.http.status;\n        }\n      }\n\n      body = prettyJSONStringify(serializeGraphQLResponse(response));\n    }\n  } catch (error) {\n    if (error instanceof HttpQueryError) {\n      throw error;\n    }\n    return throwHttpGraphQLError(500, [error as Error], options);\n  }\n\n  responseInit.headers!['Content-Length'] = Buffer.byteLength(\n    body,\n    'utf8',\n  ).toString();\n\n  return {\n    graphqlResponse: body,\n    responseInit,\n  };\n}\n\nfunction parseGraphQLRequest(\n  httpRequest: Pick<Request, 'url' | 'method' | 'headers'>,\n  requestParams: Record<string, any>,\n): GraphQLRequest {\n  let queryString: string | undefined = requestParams.query;\n  let extensions = requestParams.extensions;\n\n  if (typeof extensions === 'string' && extensions !== '') {\n    // For GET requests, we have to JSON-parse extensions. (For POST\n    // requests they get parsed as part of parsing the larger body they're\n    // inside.)\n    try {\n      extensions = JSON.parse(extensions);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Extensions are invalid JSON.');\n    }\n  }\n\n  if (queryString && typeof queryString !== 'string') {\n    // Check for a common error first.\n    if ((queryString as any).kind === 'Document') {\n      throw new HttpQueryError(\n        400,\n        \"GraphQL queries must be strings. It looks like you're sending the \" +\n          'internal graphql-js representation of a parsed query in your ' +\n          'request instead of a request in the GraphQL query language. You ' +\n          'can convert an AST to a string using the `print` function from ' +\n          '`graphql`, or use a client like `apollo-client` which converts ' +\n          'the internal representation to a string for you.',\n      );\n    } else {\n      throw new HttpQueryError(400, 'GraphQL queries must be strings.');\n    }\n  }\n\n  const operationName = requestParams.operationName;\n\n  let variables = requestParams.variables;\n  if (typeof variables === 'string' && variables !== '') {\n    try {\n      // XXX Really we should only do this for GET requests, but for\n      // compatibility reasons we'll keep doing this at least for now for\n      // broken clients that ship variables in a string for no good reason.\n      variables = JSON.parse(variables);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Variables are invalid JSON.');\n    }\n  }\n\n  return {\n    query: queryString,\n    operationName,\n    variables,\n    extensions,\n    http: httpRequest,\n  };\n}\n\n// GET operations should only be queries (not mutations). We want to throw\n// a particular HTTP error in that case.\nconst checkOperationPlugin: ApolloServerPlugin = {\n  async requestDidStart() {\n    return {\n      async didResolveOperation({ request, operation }) {\n        if (!request.http) return;\n\n        if (request.http.method === 'GET' && operation.operation !== 'query') {\n          throw new HttpQueryError(\n            405,\n            `GET supports only query operation`,\n            false,\n            {\n              Allow: 'POST',\n            },\n          );\n        }\n      },\n    };\n  },\n};\n\nfunction serializeGraphQLResponse(\n  response: GraphQLResponse,\n): Pick<GraphQLResponse, 'errors' | 'data' | 'extensions'> {\n  // See https://github.com/facebook/graphql/pull/384 for why\n  // errors comes first.\n  return {\n    errors: response.errors,\n    data: response.data,\n    extensions: response.extensions,\n  };\n}\n\n// The result of a curl does not appear well in the terminal, so we add an extra new line\nfunction prettyJSONStringify(value: any) {\n  return JSON.stringify(value) + '\\n';\n}\n\nexport function cloneObject<T extends Object>(object: T): T {\n  return Object.assign(Object.create(Object.getPrototypeOf(object)), object);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}