{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calculateReferencedFieldsByType = void 0;\nconst graphql_1 = require(\"graphql\");\nconst usage_reporting_protobuf_1 = require(\"@apollo/usage-reporting-protobuf\");\nfunction calculateReferencedFieldsByType({\n  document,\n  schema,\n  resolvedOperationName\n}) {\n  const documentSeparatedByOperation = (0, graphql_1.separateOperations)(document);\n  const filteredDocument = documentSeparatedByOperation[resolvedOperationName !== null && resolvedOperationName !== void 0 ? resolvedOperationName : \"\"];\n  if (!filteredDocument) {\n    throw Error(`shouldn't happen: operation '${resolvedOperationName !== null && resolvedOperationName !== void 0 ? resolvedOperationName : \"\"}' not found`);\n  }\n  const typeInfo = new graphql_1.TypeInfo(schema);\n  const interfaces = new Set();\n  const referencedFieldSetByType = Object.create(null);\n  (0, graphql_1.visit)(filteredDocument, (0, graphql_1.visitWithTypeInfo)(typeInfo, {\n    Field(field) {\n      const fieldName = field.name.value;\n      const parentType = typeInfo.getParentType();\n      if (!parentType) {\n        throw Error(`shouldn't happen: missing parent type for field ${fieldName}`);\n      }\n      const parentTypeName = parentType.name;\n      if (!referencedFieldSetByType[parentTypeName]) {\n        referencedFieldSetByType[parentTypeName] = new Set();\n        if ((0, graphql_1.isInterfaceType)(parentType)) {\n          interfaces.add(parentTypeName);\n        }\n      }\n      referencedFieldSetByType[parentTypeName].add(fieldName);\n    }\n  }));\n  const referencedFieldsByType = Object.create(null);\n  for (const [typeName, fieldNames] of Object.entries(referencedFieldSetByType)) {\n    referencedFieldsByType[typeName] = new usage_reporting_protobuf_1.ReferencedFieldsForType({\n      fieldNames: [...fieldNames],\n      isInterface: interfaces.has(typeName)\n    });\n  }\n  return referencedFieldsByType;\n}\nexports.calculateReferencedFieldsByType = calculateReferencedFieldsByType;","map":{"version":3,"names":["graphql_1","require","usage_reporting_protobuf_1","calculateReferencedFieldsByType","document","schema","resolvedOperationName","documentSeparatedByOperation","separateOperations","filteredDocument","Error","typeInfo","TypeInfo","interfaces","Set","referencedFieldSetByType","Object","create","visit","visitWithTypeInfo","Field","field","fieldName","name","value","parentType","getParentType","parentTypeName","isInterfaceType","add","referencedFieldsByType","typeName","fieldNames","entries","ReferencedFieldsForType","isInterface","has","exports"],"sources":["C:\\Users\\Hamza Arrouida\\Desktop\\PROJECTS\\SNRT\\audio-managment-v2 [enhanced]\\node_modules\\@apollo\\utils.usagereporting\\src\\calculateReferencedFieldsByType.ts"],"sourcesContent":["import {\n  DocumentNode,\n  GraphQLSchema,\n  isInterfaceType,\n  separateOperations,\n  TypeInfo,\n  visit,\n  visitWithTypeInfo,\n} from \"graphql\";\nimport { ReferencedFieldsForType } from \"@apollo/usage-reporting-protobuf\";\n\nexport interface OperationDerivedData {\n  signature: string;\n  referencedFieldsByType: ReferencedFieldsByType;\n}\n\nexport type ReferencedFieldsByType = Record<string, ReferencedFieldsForType>;\n\nexport function calculateReferencedFieldsByType({\n  document,\n  schema,\n  resolvedOperationName,\n}: {\n  document: DocumentNode;\n  resolvedOperationName: string | null;\n  schema: GraphQLSchema;\n}): ReferencedFieldsByType {\n  // If the document contains multiple operations, we only care about fields\n  // referenced in the operation we're using and in fragments that are\n  // (transitively) spread by that operation. (This is because Studio's field\n  // usage accounting is all by operation, not by document.) This does mean that\n  // a field can be textually present in a GraphQL document (and need to exist\n  // for validation) without being represented in the reported referenced fields\n  // structure, but we'd need to change the data model of Studio to be based on\n  // documents rather than fields if we wanted to improve that.\n  const documentSeparatedByOperation = separateOperations(document);\n  const filteredDocument =\n    documentSeparatedByOperation[resolvedOperationName ?? \"\"];\n  if (!filteredDocument) {\n    // This shouldn't happen because we only should call this function on\n    // properly executable documents.\n    throw Error(\n      `shouldn't happen: operation '${resolvedOperationName ?? \"\"}' not found`,\n    );\n  }\n  const typeInfo = new TypeInfo(schema);\n  const interfaces = new Set<string>();\n  const referencedFieldSetByType: Record<string, Set<string>> = Object.create(\n    null,\n  );\n  visit(\n    filteredDocument,\n    visitWithTypeInfo(typeInfo, {\n      Field(field) {\n        const fieldName = field.name.value;\n        const parentType = typeInfo.getParentType();\n        if (!parentType) {\n          throw Error(\n            `shouldn't happen: missing parent type for field ${fieldName}`,\n          );\n        }\n        const parentTypeName = parentType.name;\n        if (!referencedFieldSetByType[parentTypeName]) {\n          referencedFieldSetByType[parentTypeName] = new Set<string>();\n          if (isInterfaceType(parentType)) {\n            interfaces.add(parentTypeName);\n          }\n        }\n\n        // We know this is set to an empty Set if it didn't exist immediately above\n        referencedFieldSetByType[parentTypeName]!.add(fieldName);\n      },\n    }),\n  );\n\n  // Convert from initial representation (which uses Sets to avoid quadratic\n  // behavior) to the protobufjs objects. (We could also use js_use_toArray here\n  // but that seems a little overkill.)\n  const referencedFieldsByType = Object.create(null);\n  for (const [typeName, fieldNames] of Object.entries(\n    referencedFieldSetByType,\n  )) {\n    referencedFieldsByType[typeName] = new ReferencedFieldsForType({\n      fieldNames: [...fieldNames],\n      isInterface: interfaces.has(typeName),\n    });\n  }\n  return referencedFieldsByType;\n}\n"],"mappings":";;;;;;AAAA,MAAAA,SAAA,GAAAC,OAAA;AASA,MAAAC,0BAAA,GAAAD,OAAA;AASA,SAAgBE,+BAA+BA,CAAC;EAC9CC,QAAQ;EACRC,MAAM;EACNC;AAAqB,CAKtB;EASC,MAAMC,4BAA4B,GAAG,IAAAP,SAAA,CAAAQ,kBAAkB,EAACJ,QAAQ,CAAC;EACjE,MAAMK,gBAAgB,GACpBF,4BAA4B,CAACD,qBAAqB,aAArBA,qBAAqB,cAArBA,qBAAqB,GAAI,EAAE,CAAC;EAC3D,IAAI,CAACG,gBAAgB,EAAE;IAGrB,MAAMC,KAAK,CACT,gCAAgCJ,qBAAqB,aAArBA,qBAAqB,cAArBA,qBAAqB,GAAI,EAAE,aAAa,CACzE;;EAEH,MAAMK,QAAQ,GAAG,IAAIX,SAAA,CAAAY,QAAQ,CAACP,MAAM,CAAC;EACrC,MAAMQ,UAAU,GAAG,IAAIC,GAAG,EAAU;EACpC,MAAMC,wBAAwB,GAAgCC,MAAM,CAACC,MAAM,CACzE,IAAI,CACL;EACD,IAAAjB,SAAA,CAAAkB,KAAK,EACHT,gBAAgB,EAChB,IAAAT,SAAA,CAAAmB,iBAAiB,EAACR,QAAQ,EAAE;IAC1BS,KAAKA,CAACC,KAAK;MACT,MAAMC,SAAS,GAAGD,KAAK,CAACE,IAAI,CAACC,KAAK;MAClC,MAAMC,UAAU,GAAGd,QAAQ,CAACe,aAAa,EAAE;MAC3C,IAAI,CAACD,UAAU,EAAE;QACf,MAAMf,KAAK,CACT,mDAAmDY,SAAS,EAAE,CAC/D;;MAEH,MAAMK,cAAc,GAAGF,UAAU,CAACF,IAAI;MACtC,IAAI,CAACR,wBAAwB,CAACY,cAAc,CAAC,EAAE;QAC7CZ,wBAAwB,CAACY,cAAc,CAAC,GAAG,IAAIb,GAAG,EAAU;QAC5D,IAAI,IAAAd,SAAA,CAAA4B,eAAe,EAACH,UAAU,CAAC,EAAE;UAC/BZ,UAAU,CAACgB,GAAG,CAACF,cAAc,CAAC;;;MAKlCZ,wBAAwB,CAACY,cAAc,CAAE,CAACE,GAAG,CAACP,SAAS,CAAC;IAC1D;GACD,CAAC,CACH;EAKD,MAAMQ,sBAAsB,GAAGd,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAClD,KAAK,MAAM,CAACc,QAAQ,EAAEC,UAAU,CAAC,IAAIhB,MAAM,CAACiB,OAAO,CACjDlB,wBAAwB,CACzB,EAAE;IACDe,sBAAsB,CAACC,QAAQ,CAAC,GAAG,IAAI7B,0BAAA,CAAAgC,uBAAuB,CAAC;MAC7DF,UAAU,EAAE,CAAC,GAAGA,UAAU,CAAC;MAC3BG,WAAW,EAAEtB,UAAU,CAACuB,GAAG,CAACL,QAAQ;KACrC,CAAC;;EAEJ,OAAOD,sBAAsB;AAC/B;AAtEAO,OAAA,CAAAlC,+BAAA,GAAAA,+BAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}