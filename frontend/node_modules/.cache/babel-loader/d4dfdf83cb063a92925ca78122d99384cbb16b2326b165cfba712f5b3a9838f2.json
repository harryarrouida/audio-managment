{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OurContextualizedStats = exports.OurReport = exports.SizeEstimator = void 0;\nconst durationHistogram_1 = require(\"./durationHistogram\");\nconst apollo_reporting_protobuf_1 = require(\"apollo-reporting-protobuf\");\nconst iterateOverTrace_1 = require(\"./iterateOverTrace\");\nclass SizeEstimator {\n  constructor() {\n    this.bytes = 0;\n  }\n}\nexports.SizeEstimator = SizeEstimator;\nclass OurReport {\n  constructor(header) {\n    this.header = header;\n    this.tracesPreAggregated = false;\n    this.tracesPerQuery = Object.create(null);\n    this.endTime = null;\n    this.operationCount = 0;\n    this.sizeEstimator = new SizeEstimator();\n  }\n  ensureCountsAreIntegers() {\n    for (const tracesAndStats of Object.values(this.tracesPerQuery)) {\n      tracesAndStats.ensureCountsAreIntegers();\n    }\n  }\n  addTrace({\n    statsReportKey,\n    trace,\n    asTrace,\n    includeTracesContributingToStats,\n    referencedFieldsByType\n  }) {\n    const tracesAndStats = this.getTracesAndStats({\n      statsReportKey,\n      referencedFieldsByType\n    });\n    if (asTrace) {\n      const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();\n      tracesAndStats.trace.push(encodedTrace);\n      this.sizeEstimator.bytes += 2 + encodedTrace.length;\n    } else {\n      tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);\n      if (includeTracesContributingToStats) {\n        const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();\n        tracesAndStats.internalTracesContributingToStats.push(encodedTrace);\n        this.sizeEstimator.bytes += 2 + encodedTrace.length;\n      }\n    }\n  }\n  getTracesAndStats({\n    statsReportKey,\n    referencedFieldsByType\n  }) {\n    const existing = this.tracesPerQuery[statsReportKey];\n    if (existing) {\n      return existing;\n    }\n    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n    for (const [typeName, referencedFieldsForType] of Object.entries(referencedFieldsByType)) {\n      this.sizeEstimator.bytes += 2 + 2;\n      if (referencedFieldsForType.isInterface) {\n        this.sizeEstimator.bytes += 2;\n      }\n      this.sizeEstimator.bytes += estimatedBytesForString(typeName);\n      for (const fieldName of referencedFieldsForType.fieldNames) {\n        this.sizeEstimator.bytes += estimatedBytesForString(fieldName);\n      }\n    }\n    return this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(referencedFieldsByType);\n  }\n}\nexports.OurReport = OurReport;\nclass OurTracesAndStats {\n  constructor(referencedFieldsByType) {\n    this.referencedFieldsByType = referencedFieldsByType;\n    this.trace = [];\n    this.statsWithContext = new StatsByContext();\n    this.internalTracesContributingToStats = [];\n  }\n  ensureCountsAreIntegers() {\n    this.statsWithContext.ensureCountsAreIntegers();\n  }\n}\nclass StatsByContext {\n  constructor() {\n    this.map = Object.create(null);\n  }\n  toArray() {\n    return Object.values(this.map);\n  }\n  ensureCountsAreIntegers() {\n    for (const contextualizedStats of Object.values(this.map)) {\n      contextualizedStats.ensureCountsAreIntegers();\n    }\n  }\n  addTrace(trace, sizeEstimator) {\n    this.getContextualizedStats(trace, sizeEstimator).addTrace(trace, sizeEstimator);\n  }\n  getContextualizedStats(trace, sizeEstimator) {\n    const statsContext = {\n      clientName: trace.clientName,\n      clientVersion: trace.clientVersion\n    };\n    const statsContextKey = JSON.stringify(statsContext);\n    const existing = this.map[statsContextKey];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += 20 + estimatedBytesForString(trace.clientName) + estimatedBytesForString(trace.clientVersion);\n    const contextualizedStats = new OurContextualizedStats(statsContext);\n    this.map[statsContextKey] = contextualizedStats;\n    return contextualizedStats;\n  }\n}\nclass OurContextualizedStats {\n  constructor(context) {\n    this.context = context;\n    this.queryLatencyStats = new OurQueryLatencyStats();\n    this.perTypeStat = Object.create(null);\n  }\n  ensureCountsAreIntegers() {\n    for (const typeStat of Object.values(this.perTypeStat)) {\n      typeStat.ensureCountsAreIntegers();\n    }\n  }\n  addTrace(trace, sizeEstimator) {\n    var _a;\n    const {\n      fieldExecutionWeight\n    } = trace;\n    if (!fieldExecutionWeight) {\n      this.queryLatencyStats.requestsWithoutFieldInstrumentation++;\n    }\n    this.queryLatencyStats.requestCount++;\n    if (trace.fullQueryCacheHit) {\n      this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace.durationNs);\n      this.queryLatencyStats.cacheHits++;\n    } else {\n      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n    }\n    if (!trace.fullQueryCacheHit && ((_a = trace.cachePolicy) === null || _a === void 0 ? void 0 : _a.maxAgeNs) != null) {\n      switch (trace.cachePolicy.scope) {\n        case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE:\n          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);\n          break;\n        case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC:\n          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);\n          break;\n      }\n    }\n    if (trace.persistedQueryHit) {\n      this.queryLatencyStats.persistedQueryHits++;\n    }\n    if (trace.persistedQueryRegister) {\n      this.queryLatencyStats.persistedQueryMisses++;\n    }\n    if (trace.forbiddenOperation) {\n      this.queryLatencyStats.forbiddenOperationCount++;\n    }\n    if (trace.registeredOperation) {\n      this.queryLatencyStats.registeredOperationCount++;\n    }\n    let hasError = false;\n    const traceNodeStats = (node, path) => {\n      var _a, _b, _c, _d, _e;\n      if ((_a = node.error) === null || _a === void 0 ? void 0 : _a.length) {\n        hasError = true;\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n        path.toArray().forEach(subPath => {\n          currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);\n        });\n        currPathErrorStats.requestsWithErrorsCount += 1;\n        currPathErrorStats.errorsCount += node.error.length;\n      }\n      if (fieldExecutionWeight) {\n        const fieldName = node.originalFieldName || node.responseName;\n        if (node.parentType && fieldName && node.type && node.endTime != null && node.startTime != null && node.endTime >= node.startTime) {\n          const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n          const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);\n          fieldStat.errorsCount += (_c = (_b = node.error) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;\n          fieldStat.observedExecutionCount++;\n          fieldStat.estimatedExecutionCount += fieldExecutionWeight;\n          fieldStat.requestsWithErrorsCount += ((_e = (_d = node.error) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0 ? 1 : 0;\n          fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime, fieldExecutionWeight);\n        }\n      }\n      return false;\n    };\n    (0, iterateOverTrace_1.iterateOverTrace)(trace, traceNodeStats, true);\n    if (hasError) {\n      this.queryLatencyStats.requestsWithErrorsCount++;\n    }\n  }\n  getTypeStat(parentType, sizeEstimator) {\n    const existing = this.perTypeStat[parentType];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(parentType);\n    const typeStat = new OurTypeStat();\n    this.perTypeStat[parentType] = typeStat;\n    return typeStat;\n  }\n}\nexports.OurContextualizedStats = OurContextualizedStats;\nclass OurQueryLatencyStats {\n  constructor() {\n    this.latencyCount = new durationHistogram_1.DurationHistogram();\n    this.requestCount = 0;\n    this.requestsWithoutFieldInstrumentation = 0;\n    this.cacheHits = 0;\n    this.persistedQueryHits = 0;\n    this.persistedQueryMisses = 0;\n    this.cacheLatencyCount = new durationHistogram_1.DurationHistogram();\n    this.rootErrorStats = new OurPathErrorStats();\n    this.requestsWithErrorsCount = 0;\n    this.publicCacheTtlCount = new durationHistogram_1.DurationHistogram();\n    this.privateCacheTtlCount = new durationHistogram_1.DurationHistogram();\n    this.registeredOperationCount = 0;\n    this.forbiddenOperationCount = 0;\n  }\n}\nclass OurPathErrorStats {\n  constructor() {\n    this.children = Object.create(null);\n    this.errorsCount = 0;\n    this.requestsWithErrorsCount = 0;\n  }\n  getChild(subPath, sizeEstimator) {\n    const existing = this.children[subPath];\n    if (existing) {\n      return existing;\n    }\n    const child = new OurPathErrorStats();\n    this.children[subPath] = child;\n    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n    return child;\n  }\n}\nclass OurTypeStat {\n  constructor() {\n    this.perFieldStat = Object.create(null);\n  }\n  getFieldStat(fieldName, returnType, sizeEstimator) {\n    const existing = this.perFieldStat[fieldName];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(fieldName) + estimatedBytesForString(returnType) + 10;\n    const fieldStat = new OurFieldStat(returnType);\n    this.perFieldStat[fieldName] = fieldStat;\n    return fieldStat;\n  }\n  ensureCountsAreIntegers() {\n    for (const fieldStat of Object.values(this.perFieldStat)) {\n      fieldStat.ensureCountsAreIntegers();\n    }\n  }\n}\nclass OurFieldStat {\n  constructor(returnType) {\n    this.returnType = returnType;\n    this.errorsCount = 0;\n    this.observedExecutionCount = 0;\n    this.estimatedExecutionCount = 0;\n    this.requestsWithErrorsCount = 0;\n    this.latencyCount = new durationHistogram_1.DurationHistogram();\n  }\n  ensureCountsAreIntegers() {\n    this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);\n  }\n}\nfunction estimatedBytesForString(s) {\n  return 2 + Buffer.byteLength(s);\n}","map":{"version":3,"names":["durationHistogram_1","require","apollo_reporting_protobuf_1","iterateOverTrace_1","SizeEstimator","constructor","bytes","exports","OurReport","header","tracesPreAggregated","tracesPerQuery","Object","create","endTime","operationCount","sizeEstimator","ensureCountsAreIntegers","tracesAndStats","values","addTrace","statsReportKey","trace","asTrace","includeTracesContributingToStats","referencedFieldsByType","getTracesAndStats","encodedTrace","Trace","encode","finish","push","length","statsWithContext","internalTracesContributingToStats","existing","estimatedBytesForString","typeName","referencedFieldsForType","entries","isInterface","fieldName","fieldNames","OurTracesAndStats","StatsByContext","map","toArray","contextualizedStats","getContextualizedStats","statsContext","clientName","clientVersion","statsContextKey","JSON","stringify","OurContextualizedStats","context","queryLatencyStats","OurQueryLatencyStats","perTypeStat","typeStat","fieldExecutionWeight","requestsWithoutFieldInstrumentation","requestCount","fullQueryCacheHit","cacheLatencyCount","incrementDuration","durationNs","cacheHits","latencyCount","_a","cachePolicy","maxAgeNs","scope","CachePolicy","Scope","PRIVATE","privateCacheTtlCount","PUBLIC","publicCacheTtlCount","persistedQueryHit","persistedQueryHits","persistedQueryRegister","persistedQueryMisses","forbiddenOperation","forbiddenOperationCount","registeredOperation","registeredOperationCount","hasError","traceNodeStats","node","path","error","currPathErrorStats","rootErrorStats","forEach","subPath","getChild","requestsWithErrorsCount","errorsCount","originalFieldName","responseName","parentType","type","startTime","getTypeStat","fieldStat","getFieldStat","_c","_b","observedExecutionCount","estimatedExecutionCount","_e","_d","iterateOverTrace","OurTypeStat","DurationHistogram","OurPathErrorStats","children","child","perFieldStat","returnType","OurFieldStat","Math","floor","s","Buffer","byteLength"],"sources":["C:\\Users\\Hamza Arrouida\\Desktop\\PROJECTS\\SNRT\\audio-managment-v2 [enhanced]\\node_modules\\apollo-server-core\\src\\plugin\\usageReporting\\stats.ts"],"sourcesContent":["import { DurationHistogram } from './durationHistogram';\nimport {\n  IFieldStat,\n  IPathErrorStats,\n  IQueryLatencyStats,\n  IStatsContext,\n  Trace,\n  ITypeStat,\n  IContextualizedStats,\n  ReportHeader,\n  google,\n  ITracesAndStats,\n  IReport,\n} from 'apollo-reporting-protobuf';\nimport { iterateOverTrace, ResponseNamePath } from './iterateOverTrace';\nimport type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';\n\n// protobuf.js exports both a class and an interface (starting with I) for each\n// message type. The class is what it produces when it decodes the message; the\n// interface is what is accepted as input. We build up our messages using custom\n// types implementing the interfaces, so that we can take advantage of the\n// js_use_toArray option we added to our protobuf.js fork which allows us to use\n// classes like DurationHistogram to generate repeated fields. We end up\n// re-creating most of the report structure as custom classes (starting with\n// \"Our\"). TypeScript validates that we've properly listed all of the message\n// fields with the appropriate types (we use `Required` to ensure we implement\n// all message fields). Using our own classes has other advantages, like being\n// able to specify that nested messages are instances of the same class rather\n// than the interface type and thus that they have non-null fields (because the\n// interface type allows all fields to be optional, even though the protobuf\n// format doesn't differentiate between missing and falsey).\n\nexport class SizeEstimator {\n  bytes = 0;\n}\nexport class OurReport implements Required<IReport> {\n  // Apollo Server includes each operation either as aggregated stats or as a\n  // trace, but not both. Other reporting agents such as Apollo Router include\n  // all operations in stats (even those that are sent as traces), and they set\n  // this flag to true.\n  tracesPreAggregated = false;\n\n  constructor(readonly header: ReportHeader) {}\n  readonly tracesPerQuery: Record<string, OurTracesAndStats> =\n    Object.create(null);\n  endTime: google.protobuf.ITimestamp | null = null;\n  operationCount = 0;\n  // A rough estimate of the number of bytes currently in the report. We start\n  // at zero and don't count `header` and `endTime`, which have the same size\n  // for every report. This really is a rough estimate, so we don't stress too\n  // much about counting bytes for the tags and string/message lengths, etc:\n  // we mostly just count the lengths of strings plus some estimates for the\n  // messages with a bunch of numbers in them.\n  //\n  // We store this in a class so we can pass it down as a reference to other\n  // methods which increment it.\n  readonly sizeEstimator = new SizeEstimator();\n\n  ensureCountsAreIntegers() {\n    for (const tracesAndStats of Object.values(this.tracesPerQuery)) {\n      tracesAndStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace({\n    statsReportKey,\n    trace,\n    asTrace,\n    includeTracesContributingToStats,\n    referencedFieldsByType,\n  }: {\n    statsReportKey: string;\n    trace: Trace;\n    asTrace: boolean;\n    includeTracesContributingToStats: boolean;\n    referencedFieldsByType: ReferencedFieldsByType;\n  }) {\n    const tracesAndStats = this.getTracesAndStats({\n      statsReportKey,\n      referencedFieldsByType,\n    });\n    if (asTrace) {\n      const encodedTrace = Trace.encode(trace).finish();\n      tracesAndStats.trace.push(encodedTrace);\n      this.sizeEstimator.bytes += 2 + encodedTrace.length;\n    } else {\n      tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);\n      if (includeTracesContributingToStats) {\n        // For specific use inside Apollo's infrastructure to help validate that\n        // the code in this file matches similar code in Apollo's servers,\n        // include the traces that contribute to the stats. Doing this outside\n        // of Apollo's infrastructure only serves to make reports larger with no\n        // other advantage.\n        const encodedTrace = Trace.encode(trace).finish();\n        tracesAndStats.internalTracesContributingToStats.push(encodedTrace);\n        this.sizeEstimator.bytes += 2 + encodedTrace.length;\n      }\n    }\n  }\n\n  private getTracesAndStats({\n    statsReportKey,\n    referencedFieldsByType,\n  }: {\n    statsReportKey: string;\n    referencedFieldsByType: ReferencedFieldsByType;\n  }) {\n    const existing = this.tracesPerQuery[statsReportKey];\n    if (existing) {\n      return existing;\n    }\n    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n\n    // Update the size estimator for the referenced field structure.\n    for (const [typeName, referencedFieldsForType] of Object.entries(\n      referencedFieldsByType,\n    )) {\n      // Two bytes each for the map entry and for the ReferencedFieldsForType,\n      // and for the isInterface bool if it's set.\n      this.sizeEstimator.bytes += 2 + 2;\n      if (referencedFieldsForType.isInterface) {\n        this.sizeEstimator.bytes += 2;\n      }\n      this.sizeEstimator.bytes += estimatedBytesForString(typeName);\n      for (const fieldName of referencedFieldsForType.fieldNames) {\n        this.sizeEstimator.bytes += estimatedBytesForString(fieldName);\n      }\n    }\n\n    // Include the referenced fields map in the report. (In an ideal world we\n    // could have a slightly more sophisticated protocol and ingestion pipeline\n    // that allowed us to only have to send this data once for each\n    // schema/operation pair.)\n    return (this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(\n      referencedFieldsByType,\n    ));\n  }\n}\n\nclass OurTracesAndStats implements Required<ITracesAndStats> {\n  constructor(readonly referencedFieldsByType: ReferencedFieldsByType) {}\n  readonly trace: Uint8Array[] = [];\n  readonly statsWithContext = new StatsByContext();\n  readonly internalTracesContributingToStats: Uint8Array[] = [];\n\n  ensureCountsAreIntegers() {\n    this.statsWithContext.ensureCountsAreIntegers();\n  }\n}\n\nclass StatsByContext {\n  readonly map: { [k: string]: OurContextualizedStats } = Object.create(null);\n\n  /**\n   * This function is used by the protobuf generator to convert this map into\n   * an array of contextualized stats to serialize\n   */\n  toArray(): IContextualizedStats[] {\n    return Object.values(this.map);\n  }\n\n  ensureCountsAreIntegers() {\n    for (const contextualizedStats of Object.values(this.map)) {\n      contextualizedStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace(trace: Trace, sizeEstimator: SizeEstimator) {\n    this.getContextualizedStats(trace, sizeEstimator).addTrace(\n      trace,\n      sizeEstimator,\n    );\n  }\n\n  private getContextualizedStats(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n  ): OurContextualizedStats {\n    const statsContext: IStatsContext = {\n      clientName: trace.clientName,\n      clientVersion: trace.clientVersion,\n    };\n    const statsContextKey = JSON.stringify(statsContext);\n\n    const existing = this.map[statsContextKey];\n    if (existing) {\n      return existing;\n    }\n    // Adding a ContextualizedStats means adding a StatsContext plus a\n    // QueryLatencyStats. Let's guess about 20 bytes for a QueryLatencyStats;\n    // it'll be more if more features are used (like cache, APQ, etc).\n    sizeEstimator.bytes +=\n      20 +\n      estimatedBytesForString(trace.clientName) +\n      estimatedBytesForString(trace.clientVersion);\n    const contextualizedStats = new OurContextualizedStats(statsContext);\n    this.map[statsContextKey] = contextualizedStats;\n    return contextualizedStats;\n  }\n}\n\nexport class OurContextualizedStats implements Required<IContextualizedStats> {\n  queryLatencyStats = new OurQueryLatencyStats();\n  perTypeStat: { [k: string]: OurTypeStat } = Object.create(null);\n\n  constructor(readonly context: IStatsContext) {}\n\n  ensureCountsAreIntegers() {\n    for (const typeStat of Object.values(this.perTypeStat)) {\n      typeStat.ensureCountsAreIntegers();\n    }\n  }\n\n  // Extract statistics from the trace, and increment the estimated report size.\n  // We only add to the estimate when adding whole sub-messages. If it really\n  // mattered, we could do a lot more careful things like incrementing it\n  // whenever a numeric field on queryLatencyStats gets incremented over 0.\n  addTrace(trace: Trace, sizeEstimator: SizeEstimator) {\n    const { fieldExecutionWeight } = trace;\n    if (!fieldExecutionWeight) {\n      this.queryLatencyStats.requestsWithoutFieldInstrumentation++;\n    }\n\n    this.queryLatencyStats.requestCount++;\n    if (trace.fullQueryCacheHit) {\n      this.queryLatencyStats.cacheLatencyCount.incrementDuration(\n        trace.durationNs,\n      );\n      this.queryLatencyStats.cacheHits++;\n    } else {\n      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n    }\n\n    // We only provide stats about cache TTLs on cache misses (ie, TTLs directly\n    // calculated by the backend), not for cache hits. This matches the\n    // behavior we've had for a while when converting traces into statistics\n    // in Studio's servers.\n    if (!trace.fullQueryCacheHit && trace.cachePolicy?.maxAgeNs != null) {\n      switch (trace.cachePolicy.scope) {\n        case Trace.CachePolicy.Scope.PRIVATE:\n          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n        case Trace.CachePolicy.Scope.PUBLIC:\n          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n      }\n    }\n\n    if (trace.persistedQueryHit) {\n      this.queryLatencyStats.persistedQueryHits++;\n    }\n    if (trace.persistedQueryRegister) {\n      this.queryLatencyStats.persistedQueryMisses++;\n    }\n\n    if (trace.forbiddenOperation) {\n      this.queryLatencyStats.forbiddenOperationCount++;\n    }\n    if (trace.registeredOperation) {\n      this.queryLatencyStats.registeredOperationCount++;\n    }\n\n    let hasError = false;\n\n    const traceNodeStats = (node: Trace.INode, path: ResponseNamePath) => {\n      // Generate error stats and error path information\n      if (node.error?.length) {\n        hasError = true;\n\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n        path.toArray().forEach((subPath) => {\n          currPathErrorStats = currPathErrorStats.getChild(\n            subPath,\n            sizeEstimator,\n          );\n        });\n\n        currPathErrorStats.requestsWithErrorsCount += 1;\n        currPathErrorStats.errorsCount += node.error.length;\n      }\n\n      if (fieldExecutionWeight) {\n        // The actual field name behind the node; originalFieldName is set\n        // if an alias was used, otherwise responseName. (This is falsey for\n        // nodes that are not fields (root, array index, etc).)\n        const fieldName = node.originalFieldName || node.responseName;\n\n        // Protobuf doesn't really differentiate between \"unset\" and \"falsey\" so\n        // we're mostly actually checking that these things are non-empty string /\n        // non-zero numbers. The time fields represent the number of nanoseconds\n        // since the beginning of the entire trace, so let's pretend for the\n        // moment that it's plausible for a node to start or even end exactly when\n        // the trace started (ie, for the time values to be 0). This is unlikely\n        // in practice (everything should take at least 1ns). In practice we only\n        // write `type` and `parentType` on a Node when we write `startTime`, so\n        // the main thing we're looking out for by checking the time values is\n        // whether we somehow failed to write `endTime` at the end of the field;\n        // in this case, the `endTime >= startTime` check won't match.\n        if (\n          node.parentType &&\n          fieldName &&\n          node.type &&\n          node.endTime != null &&\n          node.startTime != null &&\n          node.endTime >= node.startTime\n        ) {\n          const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n\n          const fieldStat = typeStat.getFieldStat(\n            fieldName,\n            node.type,\n            sizeEstimator,\n          );\n\n          fieldStat.errorsCount += node.error?.length ?? 0;\n          fieldStat.observedExecutionCount++;\n          fieldStat.estimatedExecutionCount += fieldExecutionWeight;\n          // Note: this is actually counting the number of resolver calls for this\n          // field that had at least one error, not the number of overall GraphQL\n          // queries that had at least one error for this field. That doesn't seem\n          // to match the name, but it does match the other implementations of this\n          // logic.\n          fieldStat.requestsWithErrorsCount +=\n            (node.error?.length ?? 0) > 0 ? 1 : 0;\n          fieldStat.latencyCount.incrementDuration(\n            node.endTime - node.startTime,\n            // The latency histogram is always \"estimated\"; we don't track\n            // \"observed\" and \"estimated\" separately.\n            fieldExecutionWeight,\n          );\n        }\n      }\n\n      return false;\n    };\n\n    iterateOverTrace(trace, traceNodeStats, true);\n    if (hasError) {\n      this.queryLatencyStats.requestsWithErrorsCount++;\n    }\n  }\n\n  getTypeStat(parentType: string, sizeEstimator: SizeEstimator): OurTypeStat {\n    const existing = this.perTypeStat[parentType];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(parentType);\n    const typeStat = new OurTypeStat();\n    this.perTypeStat[parentType] = typeStat;\n    return typeStat;\n  }\n}\n\nclass OurQueryLatencyStats implements Required<IQueryLatencyStats> {\n  latencyCount: DurationHistogram = new DurationHistogram();\n  requestCount: number = 0;\n  requestsWithoutFieldInstrumentation: number = 0;\n  cacheHits: number = 0;\n  persistedQueryHits: number = 0;\n  persistedQueryMisses: number = 0;\n  cacheLatencyCount: DurationHistogram = new DurationHistogram();\n  rootErrorStats: OurPathErrorStats = new OurPathErrorStats();\n  requestsWithErrorsCount: number = 0;\n  publicCacheTtlCount: DurationHistogram = new DurationHistogram();\n  privateCacheTtlCount: DurationHistogram = new DurationHistogram();\n  registeredOperationCount: number = 0;\n  forbiddenOperationCount: number = 0;\n}\n\nclass OurPathErrorStats implements Required<IPathErrorStats> {\n  children: { [k: string]: OurPathErrorStats } = Object.create(null);\n  errorsCount: number = 0;\n  requestsWithErrorsCount: number = 0;\n\n  getChild(subPath: string, sizeEstimator: SizeEstimator): OurPathErrorStats {\n    const existing = this.children[subPath];\n    if (existing) {\n      return existing;\n    }\n    const child = new OurPathErrorStats();\n    this.children[subPath] = child;\n    // Include a few bytes in the estimate for the numbers etc.\n    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n    return child;\n  }\n}\n\nclass OurTypeStat implements Required<ITypeStat> {\n  perFieldStat: { [k: string]: OurFieldStat } = Object.create(null);\n\n  getFieldStat(\n    fieldName: string,\n    returnType: string,\n    sizeEstimator: SizeEstimator,\n  ): OurFieldStat {\n    const existing = this.perFieldStat[fieldName];\n    if (existing) {\n      return existing;\n    }\n    // Rough estimate of 10 bytes for the numbers in the FieldStat.\n    sizeEstimator.bytes +=\n      estimatedBytesForString(fieldName) +\n      estimatedBytesForString(returnType) +\n      10;\n    const fieldStat = new OurFieldStat(returnType);\n    this.perFieldStat[fieldName] = fieldStat;\n    return fieldStat;\n  }\n\n  ensureCountsAreIntegers() {\n    for (const fieldStat of Object.values(this.perFieldStat)) {\n      fieldStat.ensureCountsAreIntegers();\n    }\n  }\n}\n\nclass OurFieldStat implements Required<IFieldStat> {\n  errorsCount: number = 0;\n  observedExecutionCount: number = 0;\n  // Note that this number isn't necessarily an integer while it is being\n  // aggregated. Before encoding as a protobuf we call ensureCountsAreIntegers\n  // which floors it.\n  estimatedExecutionCount: number = 0;\n  requestsWithErrorsCount: number = 0;\n  latencyCount: DurationHistogram = new DurationHistogram();\n\n  constructor(readonly returnType: string) {}\n\n  ensureCountsAreIntegers() {\n    // This is the only one that ever can receive non-integers.\n    this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);\n  }\n}\n\nfunction estimatedBytesForString(s: string) {\n  // 2 is for the tag (field ID + wire type) plus the encoded length. (The\n  // encoded length takes up more than 1 byte for strings that are longer than\n  // 127 bytes, but this is an estimate.)\n  return 2 + Buffer.byteLength(s);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}