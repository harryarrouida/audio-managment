{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.iterateOverTrace = void 0;\nfunction iterateOverTrace(trace, f, includePath) {\n  const rootPath = includePath ? new RootCollectingPathsResponseNamePath() : notCollectingPathsResponseNamePath;\n  if (trace.root) {\n    if (iterateOverTraceNode(trace.root, rootPath, f)) return;\n  }\n  if (trace.queryPlan) {\n    if (iterateOverQueryPlan(trace.queryPlan, rootPath, f)) return;\n  }\n}\nexports.iterateOverTrace = iterateOverTrace;\nfunction iterateOverQueryPlan(node, rootPath, f) {\n  var _a, _b, _c, _d, _e;\n  if (!node) return false;\n  if (((_b = (_a = node.fetch) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.root) && node.fetch.serviceName) {\n    return iterateOverTraceNode(node.fetch.trace.root, rootPath.child(`service:${node.fetch.serviceName}`), f);\n  }\n  if ((_c = node.flatten) === null || _c === void 0 ? void 0 : _c.node) {\n    return iterateOverQueryPlan(node.flatten.node, rootPath, f);\n  }\n  if ((_d = node.parallel) === null || _d === void 0 ? void 0 : _d.nodes) {\n    return node.parallel.nodes.some(node => iterateOverQueryPlan(node, rootPath, f));\n  }\n  if ((_e = node.sequence) === null || _e === void 0 ? void 0 : _e.nodes) {\n    return node.sequence.nodes.some(node => iterateOverQueryPlan(node, rootPath, f));\n  }\n  return false;\n}\nfunction iterateOverTraceNode(node, path, f) {\n  var _a, _b;\n  if (f(node, path)) {\n    return true;\n  }\n  return (_b = (_a = node.child) === null || _a === void 0 ? void 0 : _a.some(child => {\n    const childPath = child.responseName ? path.child(child.responseName) : path;\n    return iterateOverTraceNode(child, childPath, f);\n  })) !== null && _b !== void 0 ? _b : false;\n}\nconst notCollectingPathsResponseNamePath = {\n  toArray() {\n    throw Error('not collecting paths!');\n  },\n  child() {\n    return this;\n  }\n};\nclass RootCollectingPathsResponseNamePath {\n  toArray() {\n    return [];\n  }\n  child(responseName) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\nclass ChildCollectingPathsResponseNamePath {\n  constructor(responseName, prev) {\n    this.responseName = responseName;\n    this.prev = prev;\n  }\n  toArray() {\n    const out = [];\n    let curr = this;\n    while (curr instanceof ChildCollectingPathsResponseNamePath) {\n      out.push(curr.responseName);\n      curr = curr.prev;\n    }\n    return out.reverse();\n  }\n  child(responseName) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}","map":{"version":3,"names":["iterateOverTrace","trace","f","includePath","rootPath","RootCollectingPathsResponseNamePath","notCollectingPathsResponseNamePath","root","iterateOverTraceNode","queryPlan","iterateOverQueryPlan","exports","node","_b","_a","fetch","serviceName","child","_c","flatten","_d","parallel","nodes","some","_e","sequence","path","childPath","responseName","toArray","Error","ChildCollectingPathsResponseNamePath","constructor","prev","out","curr","push","reverse"],"sources":["C:\\Users\\Hamza Arrouida\\Desktop\\PROJECTS\\SNRT\\audio-managment-v2 [enhanced]\\node_modules\\apollo-server-core\\src\\plugin\\usageReporting\\iterateOverTrace.ts"],"sourcesContent":["import type { Trace } from 'apollo-reporting-protobuf';\n\n/**\n * Iterates over the entire trace, calling `f` on each Trace.Node found. It\n * looks under the \"root\" node as well as any inside the query plan. If any `f`\n * returns true, it stops walking the tree.\n *\n * Each call to `f` will receive an object that implements ResponseNamePath. If\n * `includePath` is true, `f` can call `toArray()` on it to convert the\n * linked-list representation to an array of the response name (field name)\n * nodes that you navigate to get to the node (including a \"service:subgraph\"\n * top-level node if this is a federated trace). Note that we don't add anything\n * to the path for index (list element) nodes. This is because the only use case\n * we have (error path statistics) does not care about list indexes (it's not\n * that interesting to know that sometimes an error was at foo.3.bar and\n * sometimes foo.5.bar, vs just generally foo.bar).\n *\n * If `includePath` is false, we don't bother to build up the linked lists, and\n * calling `toArray()` will throw.\n */\nexport function iterateOverTrace(\n  trace: Trace,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n  includePath: boolean,\n) {\n  const rootPath = includePath\n    ? new RootCollectingPathsResponseNamePath()\n    : notCollectingPathsResponseNamePath;\n  if (trace.root) {\n    if (iterateOverTraceNode(trace.root, rootPath, f)) return;\n  }\n\n  if (trace.queryPlan) {\n    if (iterateOverQueryPlan(trace.queryPlan, rootPath, f)) return;\n  }\n}\n\n// Helper for iterateOverTrace; returns true to stop the overall walk.\nfunction iterateOverQueryPlan(\n  node: Trace.IQueryPlanNode,\n  rootPath: ResponseNamePath,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n): boolean {\n  if (!node) return false;\n\n  if (node.fetch?.trace?.root && node.fetch.serviceName) {\n    return iterateOverTraceNode(\n      node.fetch.trace.root,\n      rootPath.child(`service:${node.fetch.serviceName}`),\n      f,\n    );\n  }\n  if (node.flatten?.node) {\n    return iterateOverQueryPlan(node.flatten.node, rootPath, f);\n  }\n  if (node.parallel?.nodes) {\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    return node.parallel.nodes.some((node) =>\n      iterateOverQueryPlan(node, rootPath, f),\n    );\n  }\n  if (node.sequence?.nodes) {\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    return node.sequence.nodes.some((node) =>\n      iterateOverQueryPlan(node, rootPath, f),\n    );\n  }\n\n  return false;\n}\n\n// Helper for iterateOverTrace; returns true to stop the overall walk.\nfunction iterateOverTraceNode(\n  node: Trace.INode,\n  path: ResponseNamePath,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n): boolean {\n  // Invoke the function; if it returns true, don't descend and tell callers to\n  // stop walking.\n  if (f(node, path)) {\n    return true;\n  }\n\n  return (\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    node.child?.some((child) => {\n      const childPath = child.responseName\n        ? path.child(child.responseName)\n        : path;\n      return iterateOverTraceNode(child, childPath, f);\n    }) ?? false\n  );\n}\n\nexport interface ResponseNamePath {\n  toArray(): string[];\n  child(responseName: string): ResponseNamePath;\n}\n\nconst notCollectingPathsResponseNamePath: ResponseNamePath = {\n  toArray() {\n    throw Error('not collecting paths!');\n  },\n  child() {\n    return this;\n  },\n};\n\ntype CollectingPathsResponseNamePath =\n  | RootCollectingPathsResponseNamePath\n  | ChildCollectingPathsResponseNamePath;\nclass RootCollectingPathsResponseNamePath implements ResponseNamePath {\n  toArray() {\n    return [];\n  }\n  child(responseName: string) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\nclass ChildCollectingPathsResponseNamePath implements ResponseNamePath {\n  constructor(\n    readonly responseName: string,\n    readonly prev: CollectingPathsResponseNamePath,\n  ) {}\n  toArray() {\n    const out = [];\n    let curr: CollectingPathsResponseNamePath = this;\n    while (curr instanceof ChildCollectingPathsResponseNamePath) {\n      out.push(curr.responseName);\n      curr = curr.prev;\n    }\n    return out.reverse();\n  }\n  child(responseName: string) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}