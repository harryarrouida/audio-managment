{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","map":{"version":3,"names":[],"sources":["C:\\Users\\Hamza Arrouida\\Desktop\\PROJECTS\\SNRT\\audio-managment-v2 [enhanced]\\node_modules\\apollo-server-core\\src\\types.ts"],"sourcesContent":["import type { GraphQLSchema, DocumentNode } from 'graphql';\nimport type { IMocks } from '@graphql-tools/mock';\nimport type { IExecutableSchemaDefinition } from '@graphql-tools/schema';\nimport type {\n  ApolloConfig,\n  ValueOrPromise,\n  GraphQLExecutor,\n  ApolloConfigInput,\n} from 'apollo-server-types';\n\nimport type {\n  GraphQLServerOptions as GraphQLOptions,\n  PersistedQueryOptions,\n} from './graphqlOptions';\nimport type { ApolloServerPlugin } from 'apollo-server-plugin-base';\n\nimport type { GraphQLSchemaModule } from '@apollographql/apollo-tools';\n\nexport type { GraphQLSchemaModule };\n\nimport type { KeyValueCache } from '@apollo/utils.keyvaluecache';\nexport type { KeyValueCache };\n\nexport type Context<T = object> = T;\nexport type ContextFunction<FunctionParams = any, ProducedContext = object> = (\n  context: FunctionParams,\n) => ValueOrPromise<Context<ProducedContext>>;\n\n// A plugin can return an interface that matches `ApolloServerPlugin`, or a\n// factory function that returns `ApolloServerPlugin`.\nexport type PluginDefinition = ApolloServerPlugin | (() => ApolloServerPlugin);\n\ntype BaseConfig = Pick<\n  GraphQLOptions<Context>,\n  | 'formatError'\n  | 'debug'\n  | 'rootValue'\n  | 'validationRules'\n  | 'executor'\n  | 'formatResponse'\n  | 'fieldResolver'\n  | 'dataSources'\n  | 'logger'\n  | 'allowBatchedHttpRequests'\n>;\n\nexport type Unsubscriber = () => void;\nexport type SchemaChangeCallback = (apiSchema: GraphQLSchema) => void;\n\nexport type GraphQLServiceConfig = {\n  schema: GraphQLSchema;\n  executor: GraphQLExecutor | null;\n};\n\nexport interface GatewayInterface {\n  load(options: { apollo: ApolloConfig }): Promise<GraphQLServiceConfig>;\n\n  /**\n   * @deprecated Use `onSchemaLoadOrUpdate` instead\n   */\n  onSchemaChange?(callback: SchemaChangeCallback): Unsubscriber;\n\n  // TODO: This is optional because older gateways may not have this method,\n  //       and we only need it in certain circumstances, so we just error in\n  //       those circumstances if we don't have it.\n  onSchemaLoadOrUpdate?(\n    callback: (schemaContext: {\n      apiSchema: GraphQLSchema;\n      coreSupergraphSdl: string;\n    }) => void,\n  ): Unsubscriber;\n\n  stop(): Promise<void>;\n\n  // Note: this interface used to have an `executor` method, and also return the\n  // executor from `load()`. ApolloServer would only use the former. We dropped\n  // this method and now use the latter, which allows you to make a \"mock\n  // gateway\" that updates the schema over time but uses normal execution.\n}\n\n// This was the name used for GatewayInterface in AS2; continue to export it so\n// that older versions of `@apollo/gateway` build against AS3.\nexport interface GraphQLService extends GatewayInterface {}\n\nexport type DocumentStore = KeyValueCache<DocumentNode>;\n\n// This configuration is shared between all integrations and should include\n// fields that are not specific to a single integration\nexport interface Config<ContextFunctionParams = any> extends BaseConfig {\n  modules?: GraphQLSchemaModule[];\n\n  // These three options are always only passed directly through to\n  // makeExecutableSchema. (If you don't want to use makeExecutableSchema, pass\n  // `schema` instead.)\n  typeDefs?: IExecutableSchemaDefinition['typeDefs'];\n  resolvers?: IExecutableSchemaDefinition['resolvers'];\n  parseOptions?: IExecutableSchemaDefinition['parseOptions'];\n\n  schema?: GraphQLSchema;\n  context?: Context | ContextFunction<ContextFunctionParams>;\n  introspection?: boolean;\n  mocks?: boolean | IMocks;\n  mockEntireSchema?: boolean;\n  plugins?: PluginDefinition[];\n  persistedQueries?: PersistedQueryOptions | false;\n  gateway?: GatewayInterface;\n  stopOnTerminationSignals?: boolean;\n  apollo?: ApolloConfigInput;\n  nodeEnv?: string;\n  dangerouslyDisableValidation?: boolean;\n  documentStore?: DocumentStore | null;\n  csrfPrevention?: CSRFPreventionOptions | boolean;\n  cache?: KeyValueCache | 'bounded';\n}\n\nexport interface CSRFPreventionOptions {\n  // CSRF prevention works by only processing operations from requests whose\n  // structure indicates that if they were sent by a web browser, then the\n  // browser would have had to send a preflight OPTIONS request already. We do\n  // this by specifying some headers that a browser will never automatically set\n  // and which will trigger the browser to preflight. Apollo Server will reject\n  // any operation that does not set at least one of these headers *and* does\n  // not set a content-type (to a header whose parsed type is not\n  // application/x-www-form-urlencoded, multipart/form-data, or text/plain). If\n  // CSRF prevention is enabled (eg, with `csrfPrevention: true`) this list\n  // defaults to ['x-apollo-operation-name', 'apollo-require-preflight']. This\n  // will allow POST operations from any client and GET operations from Apollo\n  // Client Web, Apollo iOS, and Apollo Kotlin.\n  requestHeaders?: string[];\n}\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}