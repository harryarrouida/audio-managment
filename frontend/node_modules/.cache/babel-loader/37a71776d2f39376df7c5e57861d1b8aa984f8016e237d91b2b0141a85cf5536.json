{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ApolloServerPluginUsageReportingDisabled = exports.makeHTTPRequestHeaders = exports.ApolloServerPluginUsageReporting = void 0;\nconst os_1 = __importDefault(require(\"os\"));\nconst util_1 = require(\"util\");\nconst zlib_1 = require(\"zlib\");\nconst async_retry_1 = __importDefault(require(\"async-retry\"));\nconst apollo_reporting_protobuf_1 = require(\"apollo-reporting-protobuf\");\nconst apollo_server_env_1 = require(\"apollo-server-env\");\nconst node_abort_controller_1 = require(\"node-abort-controller\");\nconst apollo_server_types_1 = require(\"apollo-server-types\");\nconst operationDerivedDataCache_1 = require(\"./operationDerivedDataCache\");\nconst utils_usagereporting_1 = require(\"@apollo/utils.usagereporting\");\nconst traceTreeBuilder_1 = require(\"../traceTreeBuilder\");\nconst traceDetails_1 = require(\"./traceDetails\");\nconst graphql_1 = require(\"graphql\");\nconst schemaReporting_1 = require(\"../schemaReporting\");\nconst stats_1 = require(\"./stats\");\nconst defaultSendOperationsAsTrace_1 = require(\"./defaultSendOperationsAsTrace\");\nconst utils_usagereporting_2 = require(\"@apollo/utils.usagereporting\");\nconst gzipPromise = (0, util_1.promisify)(zlib_1.gzip);\nconst reportHeaderDefaults = {\n  hostname: os_1.default.hostname(),\n  agentVersion: `apollo-server-core@${require('../../../package.json').version}`,\n  runtimeVersion: `node ${process.version}`,\n  uname: `${os_1.default.platform()}, ${os_1.default.type()}, ${os_1.default.release()}, ${os_1.default.arch()})`\n};\nfunction ApolloServerPluginUsageReporting(options = Object.create(null)) {\n  const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;\n  const fieldLevelInstrumentation = typeof fieldLevelInstrumentationOption === 'number' ? async () => Math.random() < fieldLevelInstrumentationOption ? 1 / fieldLevelInstrumentationOption : 0 : fieldLevelInstrumentationOption ? fieldLevelInstrumentationOption : async () => true;\n  let requestDidStartHandler;\n  return {\n    __internal_plugin_id__() {\n      return 'UsageReporting';\n    },\n    async requestDidStart(requestContext) {\n      if (!requestDidStartHandler) {\n        throw Error('The usage reporting plugin has been asked to handle a request before the ' + 'server has started. See https://github.com/apollographql/apollo-server/issues/4588 ' + 'for more details.');\n      }\n      return requestDidStartHandler(requestContext);\n    },\n    async serverWillStart({\n      logger: serverLogger,\n      apollo,\n      serverlessFramework\n    }) {\n      var _a, _b, _c, _d;\n      const logger = (_a = options.logger) !== null && _a !== void 0 ? _a : serverLogger;\n      const {\n        key,\n        graphRef\n      } = apollo;\n      if (!(key && graphRef)) {\n        throw new Error(\"You've enabled usage reporting via ApolloServerPluginUsageReporting, \" + 'but you also need to provide your Apollo API key and graph ref, via ' + 'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' + 'variables or via `new ApolloServer({apollo: {key, graphRef})`.');\n      }\n      logger.info('Apollo usage reporting starting! See your graph at ' + `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`);\n      const sendReportsImmediately = (_b = options.sendReportsImmediately) !== null && _b !== void 0 ? _b : serverlessFramework;\n      let operationDerivedDataCache = null;\n      const reportByExecutableSchemaId = new Map();\n      const getReportWhichMustBeUsedImmediately = executableSchemaId => {\n        const existing = reportByExecutableSchemaId.get(executableSchemaId);\n        if (existing) {\n          return existing;\n        }\n        const report = new stats_1.OurReport(new apollo_reporting_protobuf_1.ReportHeader({\n          ...reportHeaderDefaults,\n          executableSchemaId,\n          graphRef\n        }));\n        reportByExecutableSchemaId.set(executableSchemaId, report);\n        return report;\n      };\n      const getAndDeleteReport = executableSchemaId => {\n        const report = reportByExecutableSchemaId.get(executableSchemaId);\n        if (report) {\n          reportByExecutableSchemaId.delete(executableSchemaId);\n          return report;\n        }\n        return null;\n      };\n      const overriddenExecutableSchemaId = options.overrideReportedSchema ? (0, schemaReporting_1.computeCoreSchemaHash)(options.overrideReportedSchema) : undefined;\n      let lastSeenExecutableSchemaToId;\n      let reportTimer;\n      if (!sendReportsImmediately) {\n        reportTimer = setInterval(() => sendAllReportsAndReportErrors(), options.reportIntervalMs || 10 * 1000);\n      }\n      let graphMightSupportTraces = true;\n      const sendOperationAsTrace = (_c = options.experimental_sendOperationAsTrace) !== null && _c !== void 0 ? _c : (0, defaultSendOperationsAsTrace_1.defaultSendOperationsAsTrace)();\n      const includeTracesContributingToStats = (_d = options.internal_includeTracesContributingToStats) !== null && _d !== void 0 ? _d : false;\n      let stopped = false;\n      function executableSchemaIdForSchema(schema) {\n        if ((lastSeenExecutableSchemaToId === null || lastSeenExecutableSchemaToId === void 0 ? void 0 : lastSeenExecutableSchemaToId.executableSchema) === schema) {\n          return lastSeenExecutableSchemaToId.executableSchemaId;\n        }\n        const id = (0, schemaReporting_1.computeCoreSchemaHash)((0, graphql_1.printSchema)(schema));\n        lastSeenExecutableSchemaToId = {\n          executableSchema: schema,\n          executableSchemaId: id\n        };\n        return id;\n      }\n      async function sendAllReportsAndReportErrors() {\n        await Promise.all([...reportByExecutableSchemaId.keys()].map(executableSchemaId => sendReportAndReportErrors(executableSchemaId)));\n      }\n      async function sendReportAndReportErrors(executableSchemaId) {\n        return sendReport(executableSchemaId).catch(err => {\n          if (options.reportErrorFunction) {\n            options.reportErrorFunction(err);\n          } else {\n            logger.error(err.message);\n          }\n        });\n      }\n      const sendReport = async executableSchemaId => {\n        var _a, _b;\n        let report = getAndDeleteReport(executableSchemaId);\n        if (!report || Object.keys(report.tracesPerQuery).length === 0 && report.operationCount === 0) {\n          return;\n        }\n        report.endTime = (0, traceTreeBuilder_1.dateToProtoTimestamp)(new Date());\n        report.ensureCountsAreIntegers();\n        const protobufError = apollo_reporting_protobuf_1.Report.verify(report);\n        if (protobufError) {\n          throw new Error(`Error verifying report: ${protobufError}`);\n        }\n        let message = apollo_reporting_protobuf_1.Report.encode(report).finish();\n        report = null;\n        if (options.debugPrintReports) {\n          const decodedReport = apollo_reporting_protobuf_1.Report.decode(message);\n          logger.warn(`Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`);\n        }\n        const compressed = await gzipPromise(message);\n        message = null;\n        const fetcher = (_a = options.fetcher) !== null && _a !== void 0 ? _a : apollo_server_env_1.fetch;\n        const response = await (0, async_retry_1.default)(async () => {\n          var _a;\n          const controller = new node_abort_controller_1.AbortController();\n          const abortTimeout = setTimeout(() => {\n            controller.abort();\n          }, (_a = options.requestTimeoutMs) !== null && _a !== void 0 ? _a : 30000);\n          let curResponse;\n          try {\n            const requestInit = {\n              method: 'POST',\n              headers: {\n                'user-agent': 'ApolloServerPluginUsageReporting',\n                'x-api-key': key,\n                'content-encoding': 'gzip',\n                accept: 'application/json'\n              },\n              body: compressed,\n              agent: options.requestAgent\n            };\n            requestInit.signal = controller.signal;\n            curResponse = await fetcher((options.endpointUrl || 'https://usage-reporting.api.apollographql.com') + '/api/ingress/traces', requestInit);\n          } finally {\n            clearTimeout(abortTimeout);\n          }\n          if (curResponse.status >= 500 && curResponse.status < 600) {\n            throw new Error(`HTTP status ${curResponse.status}, ${(await curResponse.text()) || '(no body)'}`);\n          } else {\n            return curResponse;\n          }\n        }, {\n          retries: (options.maxAttempts || 5) - 1,\n          minTimeout: options.minimumRetryDelayMs || 100,\n          factor: 2\n        }).catch(err => {\n          throw new Error(`Error sending report to Apollo servers: ${err.message}`);\n        });\n        if (response.status < 200 || response.status >= 300) {\n          throw new Error(`Error sending report to Apollo servers: HTTP status ${response.status}, ${(await response.text()) || '(no body)'}`);\n        }\n        if (graphMightSupportTraces && response.status === 200 && ((_b = response.headers.get('content-type')) === null || _b === void 0 ? void 0 : _b.match(/^\\s*application\\/json\\s*(?:;|$)/i))) {\n          const body = await response.text();\n          let parsedBody;\n          try {\n            parsedBody = JSON.parse(body);\n          } catch (e) {\n            throw new Error(`Error parsing response from Apollo servers: ${e}`);\n          }\n          if (parsedBody.tracesIgnored === true) {\n            logger.debug(\"This graph's organization does not have access to traces; sending all \" + 'subsequent operations as traces.');\n            graphMightSupportTraces = false;\n          }\n        }\n        if (options.debugPrintReports) {\n          logger.warn(`Apollo usage report: status ${response.status}`);\n        }\n      };\n      requestDidStartHandler = ({\n        logger: requestLogger,\n        metrics,\n        schema,\n        request: {\n          http,\n          variables\n        }\n      }) => {\n        var _a;\n        const logger = (_a = requestLogger !== null && requestLogger !== void 0 ? requestLogger : options.logger) !== null && _a !== void 0 ? _a : serverLogger;\n        const treeBuilder = new traceTreeBuilder_1.TraceTreeBuilder({\n          rewriteError: options.rewriteError,\n          logger\n        });\n        treeBuilder.startTiming();\n        metrics.startHrTime = treeBuilder.startHrTime;\n        let graphqlValidationFailure = false;\n        let graphqlUnknownOperationName = false;\n        let includeOperationInUsageReporting = null;\n        if (http) {\n          treeBuilder.trace.http = new apollo_reporting_protobuf_1.Trace.HTTP({\n            method: apollo_reporting_protobuf_1.Trace.HTTP.Method[http.method] || apollo_reporting_protobuf_1.Trace.HTTP.Method.UNKNOWN\n          });\n          if (options.sendHeaders) {\n            makeHTTPRequestHeaders(treeBuilder.trace.http, http.headers, options.sendHeaders);\n          }\n        }\n        async function maybeCallIncludeRequestHook(requestContext) {\n          if (includeOperationInUsageReporting !== null) return;\n          if (typeof options.includeRequest !== 'function') {\n            includeOperationInUsageReporting = true;\n            return;\n          }\n          includeOperationInUsageReporting = await options.includeRequest(requestContext);\n          if (typeof includeOperationInUsageReporting !== 'boolean') {\n            logger.warn(\"The 'includeRequest' async predicate function must return a boolean value.\");\n            includeOperationInUsageReporting = true;\n          }\n        }\n        let didResolveSource = false;\n        return {\n          async didResolveSource(requestContext) {\n            didResolveSource = true;\n            if (metrics.persistedQueryHit) {\n              treeBuilder.trace.persistedQueryHit = true;\n            }\n            if (metrics.persistedQueryRegister) {\n              treeBuilder.trace.persistedQueryRegister = true;\n            }\n            if (variables) {\n              treeBuilder.trace.details = (0, traceDetails_1.makeTraceDetails)(variables, options.sendVariableValues, requestContext.source);\n            }\n            const clientInfo = (options.generateClientInfo || defaultGenerateClientInfo)(requestContext);\n            if (clientInfo) {\n              const {\n                clientName,\n                clientVersion\n              } = clientInfo;\n              treeBuilder.trace.clientVersion = clientVersion || '';\n              treeBuilder.trace.clientName = clientName || '';\n            }\n          },\n          async validationDidStart() {\n            return async validationErrors => {\n              graphqlValidationFailure = validationErrors ? validationErrors.length !== 0 : false;\n            };\n          },\n          async didResolveOperation(requestContext) {\n            graphqlUnknownOperationName = requestContext.operation === undefined;\n            await maybeCallIncludeRequestHook(requestContext);\n            if (includeOperationInUsageReporting && !graphqlUnknownOperationName) {\n              if (metrics.captureTraces === undefined) {\n                const rawWeight = await fieldLevelInstrumentation(requestContext);\n                treeBuilder.trace.fieldExecutionWeight = typeof rawWeight === 'number' ? rawWeight : rawWeight ? 1 : 0;\n                metrics.captureTraces = !!treeBuilder.trace.fieldExecutionWeight;\n              }\n            }\n          },\n          async executionDidStart() {\n            if (!metrics.captureTraces) return;\n            return {\n              willResolveField({\n                info\n              }) {\n                return treeBuilder.willResolveField(info);\n              }\n            };\n          },\n          async willSendResponse(requestContext) {\n            if (!didResolveSource) return;\n            if (requestContext.errors) {\n              treeBuilder.didEncounterErrors(requestContext.errors);\n            }\n            const resolvedOperation = !!requestContext.operation;\n            await maybeCallIncludeRequestHook(requestContext);\n            treeBuilder.stopTiming();\n            const executableSchemaId = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== void 0 ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);\n            if (includeOperationInUsageReporting === false) {\n              if (resolvedOperation) getReportWhichMustBeUsedImmediately(executableSchemaId).operationCount++;\n              return;\n            }\n            treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;\n            treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;\n            treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;\n            const policyIfCacheable = requestContext.overallCachePolicy.policyIfCacheable();\n            if (policyIfCacheable) {\n              treeBuilder.trace.cachePolicy = new apollo_reporting_protobuf_1.Trace.CachePolicy({\n                scope: policyIfCacheable.scope === apollo_server_types_1.CacheScope.Private ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE : policyIfCacheable.scope === apollo_server_types_1.CacheScope.Public ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC : apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.UNKNOWN,\n                maxAgeNs: policyIfCacheable.maxAge * 1e9\n              });\n            }\n            if (metrics.queryPlanTrace) {\n              treeBuilder.trace.queryPlan = metrics.queryPlanTrace;\n            }\n            addTrace().catch(logger.error);\n            async function addTrace() {\n              if (stopped) {\n                return;\n              }\n              await new Promise(res => setImmediate(res));\n              const executableSchemaId = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== void 0 ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);\n              const {\n                trace\n              } = treeBuilder;\n              let statsReportKey = undefined;\n              let referencedFieldsByType;\n              if (!requestContext.document) {\n                statsReportKey = `## GraphQLParseFailure\\n`;\n              } else if (graphqlValidationFailure) {\n                statsReportKey = `## GraphQLValidationFailure\\n`;\n              } else if (graphqlUnknownOperationName) {\n                statsReportKey = `## GraphQLUnknownOperationName\\n`;\n              }\n              const isExecutable = statsReportKey === undefined;\n              if (statsReportKey) {\n                if (options.sendUnexecutableOperationDocuments) {\n                  trace.unexecutedOperationBody = requestContext.source;\n                  trace.unexecutedOperationName = requestContext.request.operationName || '';\n                }\n                referencedFieldsByType = Object.create(null);\n              } else {\n                const operationDerivedData = getOperationDerivedData();\n                statsReportKey = `# ${requestContext.operationName || '-'}\\n${operationDerivedData.signature}`;\n                referencedFieldsByType = operationDerivedData.referencedFieldsByType;\n              }\n              const protobufError = apollo_reporting_protobuf_1.Trace.verify(trace);\n              if (protobufError) {\n                throw new Error(`Error encoding trace: ${protobufError}`);\n              }\n              if (resolvedOperation) {\n                getReportWhichMustBeUsedImmediately(executableSchemaId).operationCount++;\n              }\n              getReportWhichMustBeUsedImmediately(executableSchemaId).addTrace({\n                statsReportKey,\n                trace,\n                asTrace: graphMightSupportTraces && (!isExecutable || !!metrics.captureTraces) && sendOperationAsTrace(trace, statsReportKey),\n                includeTracesContributingToStats,\n                referencedFieldsByType\n              });\n              if (sendReportsImmediately || getReportWhichMustBeUsedImmediately(executableSchemaId).sizeEstimator.bytes >= (options.maxUncompressedReportSize || 4 * 1024 * 1024)) {\n                await sendReportAndReportErrors(executableSchemaId);\n              }\n            }\n            function getOperationDerivedData() {\n              var _a;\n              if (!requestContext.document) {\n                throw new Error('No document?');\n              }\n              const cacheKey = (0, operationDerivedDataCache_1.operationDerivedDataCacheKey)(requestContext.queryHash, requestContext.operationName || '');\n              if (!operationDerivedDataCache || operationDerivedDataCache.forSchema !== schema) {\n                operationDerivedDataCache = {\n                  forSchema: schema,\n                  cache: (0, operationDerivedDataCache_1.createOperationDerivedDataCache)({\n                    logger\n                  })\n                };\n              }\n              const cachedOperationDerivedData = operationDerivedDataCache.cache.get(cacheKey);\n              if (cachedOperationDerivedData) {\n                return cachedOperationDerivedData;\n              }\n              const generatedSignature = (options.calculateSignature || utils_usagereporting_1.usageReportingSignature)(requestContext.document, requestContext.operationName || '');\n              const generatedOperationDerivedData = {\n                signature: generatedSignature,\n                referencedFieldsByType: (0, utils_usagereporting_2.calculateReferencedFieldsByType)({\n                  document: requestContext.document,\n                  schema,\n                  resolvedOperationName: (_a = requestContext.operationName) !== null && _a !== void 0 ? _a : null\n                })\n              };\n              operationDerivedDataCache.cache.set(cacheKey, generatedOperationDerivedData);\n              return generatedOperationDerivedData;\n            }\n          }\n        };\n      };\n      return {\n        async serverWillStop() {\n          if (reportTimer) {\n            clearInterval(reportTimer);\n            reportTimer = undefined;\n          }\n          stopped = true;\n          await sendAllReportsAndReportErrors();\n        }\n      };\n    }\n  };\n}\nexports.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;\nfunction makeHTTPRequestHeaders(http, headers, sendHeaders) {\n  if (!sendHeaders || 'none' in sendHeaders && sendHeaders.none || 'all' in sendHeaders && !sendHeaders.all) {\n    return;\n  }\n  for (const [key, value] of headers) {\n    const lowerCaseKey = key.toLowerCase();\n    if ('exceptNames' in sendHeaders && sendHeaders.exceptNames.some(exceptHeader => {\n      return exceptHeader.toLowerCase() === lowerCaseKey;\n    }) || 'onlyNames' in sendHeaders && !sendHeaders.onlyNames.some(header => {\n      return header.toLowerCase() === lowerCaseKey;\n    })) {\n      continue;\n    }\n    switch (key) {\n      case 'authorization':\n      case 'cookie':\n      case 'set-cookie':\n        break;\n      default:\n        http.requestHeaders[key] = new apollo_reporting_protobuf_1.Trace.HTTP.Values({\n          value: [value]\n        });\n    }\n  }\n}\nexports.makeHTTPRequestHeaders = makeHTTPRequestHeaders;\nfunction defaultGenerateClientInfo({\n  request\n}) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n  const clientNameHeaderKey = 'apollographql-client-name';\n  const clientVersionHeaderKey = 'apollographql-client-version';\n  if (((_b = (_a = request.http) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b.get(clientNameHeaderKey)) || ((_d = (_c = request.http) === null || _c === void 0 ? void 0 : _c.headers) === null || _d === void 0 ? void 0 : _d.get(clientVersionHeaderKey))) {\n    return {\n      clientName: (_f = (_e = request.http) === null || _e === void 0 ? void 0 : _e.headers) === null || _f === void 0 ? void 0 : _f.get(clientNameHeaderKey),\n      clientVersion: (_h = (_g = request.http) === null || _g === void 0 ? void 0 : _g.headers) === null || _h === void 0 ? void 0 : _h.get(clientVersionHeaderKey)\n    };\n  } else if ((_j = request.extensions) === null || _j === void 0 ? void 0 : _j.clientInfo) {\n    return request.extensions.clientInfo;\n  } else {\n    return {};\n  }\n}\nfunction ApolloServerPluginUsageReportingDisabled() {\n  return {\n    __internal_plugin_id__() {\n      return 'UsageReporting';\n    }\n  };\n}\nexports.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled;","map":{"version":3,"names":["os_1","__importDefault","require","util_1","zlib_1","async_retry_1","apollo_reporting_protobuf_1","apollo_server_env_1","node_abort_controller_1","apollo_server_types_1","operationDerivedDataCache_1","utils_usagereporting_1","traceTreeBuilder_1","traceDetails_1","graphql_1","schemaReporting_1","stats_1","defaultSendOperationsAsTrace_1","utils_usagereporting_2","gzipPromise","promisify","gzip","reportHeaderDefaults","hostname","default","agentVersion","version","runtimeVersion","process","uname","platform","type","release","arch","ApolloServerPluginUsageReporting","options","Object","create","fieldLevelInstrumentationOption","fieldLevelInstrumentation","Math","random","requestDidStartHandler","__internal_plugin_id__","requestDidStart","requestContext","Error","serverWillStart","logger","serverLogger","apollo","serverlessFramework","_a","key","graphRef","info","encodeURI","sendReportsImmediately","_b","operationDerivedDataCache","reportByExecutableSchemaId","Map","getReportWhichMustBeUsedImmediately","executableSchemaId","existing","get","report","OurReport","ReportHeader","set","getAndDeleteReport","delete","overriddenExecutableSchemaId","overrideReportedSchema","computeCoreSchemaHash","undefined","lastSeenExecutableSchemaToId","reportTimer","setInterval","sendAllReportsAndReportErrors","reportIntervalMs","graphMightSupportTraces","sendOperationAsTrace","_c","experimental_sendOperationAsTrace","defaultSendOperationsAsTrace","includeTracesContributingToStats","_d","internal_includeTracesContributingToStats","stopped","executableSchemaIdForSchema","schema","executableSchema","id","printSchema","Promise","all","keys","map","sendReportAndReportErrors","sendReport","catch","err","reportErrorFunction","error","message","tracesPerQuery","length","operationCount","endTime","dateToProtoTimestamp","Date","ensureCountsAreIntegers","protobufError","Report","verify","encode","finish","debugPrintReports","decodedReport","decode","warn","JSON","stringify","toJSON","compressed","fetcher","fetch","response","controller","AbortController","abortTimeout","setTimeout","abort","requestTimeoutMs","curResponse","requestInit","method","headers","accept","body","agent","requestAgent","signal","endpointUrl","clearTimeout","status","text","retries","maxAttempts","minTimeout","minimumRetryDelayMs","factor","match","parsedBody","parse","e","tracesIgnored","debug","requestLogger","metrics","request","http","variables","treeBuilder","TraceTreeBuilder","rewriteError","startTiming","startHrTime","graphqlValidationFailure","graphqlUnknownOperationName","includeOperationInUsageReporting","trace","Trace","HTTP","Method","UNKNOWN","sendHeaders","makeHTTPRequestHeaders","maybeCallIncludeRequestHook","includeRequest","didResolveSource","persistedQueryHit","persistedQueryRegister","details","makeTraceDetails","sendVariableValues","source","clientInfo","generateClientInfo","defaultGenerateClientInfo","clientName","clientVersion","validationDidStart","validationErrors","didResolveOperation","operation","captureTraces","rawWeight","fieldExecutionWeight","executionDidStart","willResolveField","willSendResponse","errors","didEncounterErrors","resolvedOperation","stopTiming","fullQueryCacheHit","responseCacheHit","forbiddenOperation","registeredOperation","policyIfCacheable","overallCachePolicy","cachePolicy","CachePolicy","scope","CacheScope","Private","Scope","PRIVATE","Public","PUBLIC","maxAgeNs","maxAge","queryPlanTrace","queryPlan","addTrace","res","setImmediate","statsReportKey","referencedFieldsByType","document","isExecutable","sendUnexecutableOperationDocuments","unexecutedOperationBody","unexecutedOperationName","operationName","operationDerivedData","getOperationDerivedData","signature","asTrace","sizeEstimator","bytes","maxUncompressedReportSize","cacheKey","operationDerivedDataCacheKey","queryHash","forSchema","cache","createOperationDerivedDataCache","cachedOperationDerivedData","generatedSignature","calculateSignature","usageReportingSignature","generatedOperationDerivedData","calculateReferencedFieldsByType","resolvedOperationName","serverWillStop","clearInterval","exports","none","value","lowerCaseKey","toLowerCase","exceptNames","some","exceptHeader","onlyNames","header","requestHeaders","Values","clientNameHeaderKey","clientVersionHeaderKey","_f","_e","_h","_g","_j","extensions","ApolloServerPluginUsageReportingDisabled"],"sources":["C:\\Users\\Hamza Arrouida\\Desktop\\PROJECTS\\SNRT\\audio-managment-v2 [enhanced]\\node_modules\\apollo-server-core\\src\\plugin\\usageReporting\\plugin.ts"],"sourcesContent":["import os from 'os';\nimport { promisify } from 'util';\nimport { gzip } from 'zlib';\nimport retry from 'async-retry';\nimport { Report, ReportHeader, Trace } from 'apollo-reporting-protobuf';\nimport { Response, fetch, Headers, RequestInit } from 'apollo-server-env';\nimport { AbortController } from 'node-abort-controller';\nimport type {\n  GraphQLRequestListener,\n  GraphQLServerListener,\n} from 'apollo-server-plugin-base';\nimport {\n  CacheScope,\n  GraphQLRequestContext,\n  GraphQLServiceContext,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextWillSendResponse,\n  BaseContext,\n} from 'apollo-server-types';\nimport {\n  createOperationDerivedDataCache,\n  OperationDerivedData,\n  operationDerivedDataCacheKey,\n} from './operationDerivedDataCache';\nimport { usageReportingSignature } from '@apollo/utils.usagereporting';\nimport type {\n  ApolloServerPluginUsageReportingOptions,\n  SendValuesBaseOptions,\n} from './options';\nimport { dateToProtoTimestamp, TraceTreeBuilder } from '../traceTreeBuilder';\nimport { makeTraceDetails } from './traceDetails';\nimport { GraphQLSchema, printSchema } from 'graphql';\nimport { computeCoreSchemaHash } from '../schemaReporting';\nimport type { InternalApolloServerPlugin } from '../../internalPlugin';\nimport { OurReport } from './stats';\nimport { defaultSendOperationsAsTrace } from './defaultSendOperationsAsTrace';\nimport {\n  calculateReferencedFieldsByType,\n  ReferencedFieldsByType,\n} from '@apollo/utils.usagereporting';\nimport type LRUCache from 'lru-cache';\n\nconst gzipPromise = promisify(gzip);\n\nconst reportHeaderDefaults = {\n  hostname: os.hostname(),\n  agentVersion: `apollo-server-core@${\n    require('../../../package.json').version\n  }`,\n  runtimeVersion: `node ${process.version}`,\n  // XXX not actually uname, but what node has easily.\n  uname: `${os.platform()}, ${os.type()}, ${os.release()}, ${os.arch()})`,\n};\n\nexport function ApolloServerPluginUsageReporting<TContext extends BaseContext>(\n  options: ApolloServerPluginUsageReportingOptions<TContext> = Object.create(\n    null,\n  ),\n): InternalApolloServerPlugin {\n  // Note: We'd like to change the default to false in Apollo Server 4, so that\n  // the default usage reporting experience doesn't include *anything* that\n  // could potentially be PII (like error messages) --- just operations and\n  // numbers.\n  const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;\n  const fieldLevelInstrumentation =\n    typeof fieldLevelInstrumentationOption === 'number'\n      ? async () =>\n          Math.random() < fieldLevelInstrumentationOption\n            ? 1 / fieldLevelInstrumentationOption\n            : 0\n      : fieldLevelInstrumentationOption\n      ? fieldLevelInstrumentationOption\n      : async () => true;\n\n  let requestDidStartHandler: (\n    requestContext: GraphQLRequestContext<TContext>,\n  ) => GraphQLRequestListener<TContext>;\n  return {\n    __internal_plugin_id__() {\n      return 'UsageReporting';\n    },\n\n    // We want to be able to access locals from `serverWillStart` in our `requestDidStart`, thus\n    // this little hack. (Perhaps we should also allow GraphQLServerListener to contain\n    // a requestDidStart?)\n    async requestDidStart(requestContext: GraphQLRequestContext<TContext>) {\n      if (!requestDidStartHandler) {\n        throw Error(\n          'The usage reporting plugin has been asked to handle a request before the ' +\n            'server has started. See https://github.com/apollographql/apollo-server/issues/4588 ' +\n            'for more details.',\n        );\n      }\n      return requestDidStartHandler(requestContext);\n    },\n\n    async serverWillStart({\n      logger: serverLogger,\n      apollo,\n      serverlessFramework,\n    }: GraphQLServiceContext): Promise<GraphQLServerListener> {\n      // Use the plugin-specific logger if one is provided; otherwise the general server one.\n      const logger = options.logger ?? serverLogger;\n      const { key, graphRef } = apollo;\n      if (!(key && graphRef)) {\n        throw new Error(\n          \"You've enabled usage reporting via ApolloServerPluginUsageReporting, \" +\n            'but you also need to provide your Apollo API key and graph ref, via ' +\n            'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' +\n            'variables or via `new ApolloServer({apollo: {key, graphRef})`.',\n        );\n      }\n\n      logger.info(\n        'Apollo usage reporting starting! See your graph at ' +\n          `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`,\n      );\n\n      // If sendReportsImmediately is not specified, we default to true if we're running\n      // with the ApolloServer designed for Lambda or similar. That's because these\n      // environments aren't designed around letting us run a background task to\n      // send reports later or hook into container destruction to flush buffered reports.\n      const sendReportsImmediately =\n        options.sendReportsImmediately ?? serverlessFramework;\n\n      // Since calculating the signature and referenced fields for usage\n      // reporting is potentially an expensive operation, we'll cache the data\n      // we generate and re-use them for repeated operations for the same\n      // `queryHash`. However, because referenced fields depend on the current\n      // schema, we want to throw it out entirely any time the schema changes.\n      let operationDerivedDataCache: {\n        forSchema: GraphQLSchema;\n        cache: LRUCache<string, OperationDerivedData>;\n      } | null = null;\n\n      // This map maps from executable schema ID (schema hash, basically) to the\n      // report we'll send about it. That's because when we're using a gateway,\n      // the schema can change over time, but each report needs to be about a\n      // single schema. We avoid having this function be a memory leak by\n      // removing values from it when we're in the process of sending reports.\n      // That means we have to be very careful never to pull a Report out of it\n      // and hang on to it for a while before writing to it, because the report\n      // might have gotten sent and discarded in the meantime. So you should\n      // only access the values of this Map via\n      // getReportWhichMustBeUsedImmediately and getAndDeleteReport, and never\n      // hang on to the value returned by getReportWhichMustBeUsedImmediately.\n      const reportByExecutableSchemaId = new Map<string, OurReport>();\n      const getReportWhichMustBeUsedImmediately = (\n        executableSchemaId: string,\n      ): OurReport => {\n        const existing = reportByExecutableSchemaId.get(executableSchemaId);\n        if (existing) {\n          return existing;\n        }\n        const report = new OurReport(\n          new ReportHeader({\n            ...reportHeaderDefaults,\n            executableSchemaId,\n            graphRef,\n          }),\n        );\n        reportByExecutableSchemaId.set(executableSchemaId, report);\n        return report;\n      };\n      const getAndDeleteReport = (\n        executableSchemaId: string,\n      ): OurReport | null => {\n        const report = reportByExecutableSchemaId.get(executableSchemaId);\n        if (report) {\n          reportByExecutableSchemaId.delete(executableSchemaId);\n          return report;\n        }\n        return null;\n      };\n\n      const overriddenExecutableSchemaId = options.overrideReportedSchema\n        ? computeCoreSchemaHash(options.overrideReportedSchema)\n        : undefined;\n\n      let lastSeenExecutableSchemaToId:\n        | {\n            executableSchema: GraphQLSchema;\n            executableSchemaId: string;\n          }\n        | undefined;\n\n      let reportTimer: NodeJS.Timer | undefined;\n      if (!sendReportsImmediately) {\n        reportTimer = setInterval(\n          () => sendAllReportsAndReportErrors(),\n          options.reportIntervalMs || 10 * 1000,\n        );\n      }\n\n      let graphMightSupportTraces = true;\n      const sendOperationAsTrace =\n        options.experimental_sendOperationAsTrace ??\n        defaultSendOperationsAsTrace();\n      const includeTracesContributingToStats =\n        options.internal_includeTracesContributingToStats ?? false;\n\n      let stopped = false;\n\n      function executableSchemaIdForSchema(schema: GraphQLSchema) {\n        if (lastSeenExecutableSchemaToId?.executableSchema === schema) {\n          return lastSeenExecutableSchemaToId.executableSchemaId;\n        }\n        const id = computeCoreSchemaHash(printSchema(schema));\n\n        // We override this variable every time we get a new schema so we cache\n        // the last seen value. It is a single-entry cache.\n        lastSeenExecutableSchemaToId = {\n          executableSchema: schema,\n          executableSchemaId: id,\n        };\n\n        return id;\n      }\n\n      async function sendAllReportsAndReportErrors(): Promise<void> {\n        await Promise.all(\n          [...reportByExecutableSchemaId.keys()].map((executableSchemaId) =>\n            sendReportAndReportErrors(executableSchemaId),\n          ),\n        );\n      }\n\n      async function sendReportAndReportErrors(\n        executableSchemaId: string,\n      ): Promise<void> {\n        return sendReport(executableSchemaId).catch((err) => {\n          // This catch block is primarily intended to catch network errors from\n          // the retried request itself, which include network errors and non-2xx\n          // HTTP errors.\n          if (options.reportErrorFunction) {\n            options.reportErrorFunction(err);\n          } else {\n            logger.error(err.message);\n          }\n        });\n      }\n\n      // Needs to be an arrow function to be confident that key is defined.\n      const sendReport = async (executableSchemaId: string): Promise<void> => {\n        let report = getAndDeleteReport(executableSchemaId);\n        if (\n          !report ||\n          (Object.keys(report.tracesPerQuery).length === 0 &&\n            report.operationCount === 0)\n        ) {\n          return;\n        }\n\n        // Set the report's overall end time. This is the timestamp that will be\n        // associated with the summarized statistics.\n        report.endTime = dateToProtoTimestamp(new Date());\n\n        report.ensureCountsAreIntegers();\n\n        const protobufError = Report.verify(report);\n        if (protobufError) {\n          throw new Error(`Error verifying report: ${protobufError}`);\n        }\n        let message: Uint8Array | null = Report.encode(report).finish();\n        // Let the original protobuf object be garbage collected (helpful if the\n        // HTTP request hangs).\n        report = null;\n\n        // Potential follow-up: we can compare message.length to\n        // report.sizeEstimator.bytes and use it to \"learn\" if our estimation is\n        // off and adjust it based on what we learn.\n\n        if (options.debugPrintReports) {\n          // In terms of verbosity, and as the name of this option suggests,\n          // this message is either an \"info\" or a \"debug\" level message.\n          // However, we are using `warn` here for compatibility reasons since\n          // the `debugPrintReports` flag pre-dated the existence of log-levels\n          // and changing this to also require `debug: true` (in addition to\n          // `debugPrintReports`) just to reach the level of verbosity to\n          // produce the output would be a breaking change.  The \"warn\" level is\n          // on by default.  There is a similar theory and comment applied\n          // below.\n          //\n          // We decode the report rather than printing the original `report`\n          // so that it includes all of the pre-encoded traces.\n          const decodedReport = Report.decode(message);\n          logger.warn(\n            `Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`,\n          );\n        }\n\n        const compressed = await gzipPromise(message);\n        // Let the uncompressed message be garbage collected (helpful if the\n        // HTTP request is slow).\n        message = null;\n\n        // Wrap fetcher with async-retry for automatic retrying\n        const fetcher = options.fetcher ?? fetch;\n        const response: Response = await retry(\n          // Retry on network errors and 5xx HTTP\n          // responses.\n          async () => {\n            // Note that once we require Node v16 we can use its global\n            // AbortController instead of the one from `node-abort-controller`.\n            const controller = new AbortController();\n            const abortTimeout = setTimeout(() => {\n              controller.abort();\n            }, options.requestTimeoutMs ?? 30_000);\n            let curResponse;\n            try {\n              const requestInit: RequestInit = {\n                method: 'POST',\n                headers: {\n                  'user-agent': 'ApolloServerPluginUsageReporting',\n                  'x-api-key': key,\n                  'content-encoding': 'gzip',\n                  accept: 'application/json',\n                },\n                body: compressed,\n                agent: options.requestAgent,\n              };\n              // The apollo-server-env Fetch API doesn't have `signal` in\n              // RequestInit, but it does work in node-fetch. We've added it\n              // already to our `Fetcher` interface (`@apollo/utils.fetcher`)\n              // that we're using in AS4 but making changes to\n              // `apollo-server-env` that could cause custom AS3 fetchers to not\n              // compile feels like a bad idea. The worst case scenario of\n              // passing in an ignored `signal` is the timeout doesn't work, in\n              // which case you're not getting the new feature but can change\n              // your fetcher to make it work.\n              (requestInit as any).signal = controller.signal;\n              curResponse = await fetcher(\n                (options.endpointUrl ||\n                  'https://usage-reporting.api.apollographql.com') +\n                  '/api/ingress/traces',\n                requestInit,\n              );\n            } finally {\n              clearTimeout(abortTimeout);\n            }\n\n            if (curResponse.status >= 500 && curResponse.status < 600) {\n              throw new Error(\n                `HTTP status ${curResponse.status}, ${\n                  (await curResponse.text()) || '(no body)'\n                }`,\n              );\n            } else {\n              return curResponse;\n            }\n          },\n          {\n            retries: (options.maxAttempts || 5) - 1,\n            minTimeout: options.minimumRetryDelayMs || 100,\n            factor: 2,\n          },\n        ).catch((err: Error) => {\n          throw new Error(\n            `Error sending report to Apollo servers: ${err.message}`,\n          );\n        });\n\n        if (response.status < 200 || response.status >= 300) {\n          // Note that we don't expect to see a 3xx here because request follows\n          // redirects.\n          throw new Error(\n            `Error sending report to Apollo servers: HTTP status ${\n              response.status\n            }, ${(await response.text()) || '(no body)'}`,\n          );\n        }\n\n        if (\n          graphMightSupportTraces &&\n          response.status === 200 &&\n          response.headers\n            .get('content-type')\n            ?.match(/^\\s*application\\/json\\s*(?:;|$)/i)\n        ) {\n          const body = await response.text();\n          let parsedBody;\n          try {\n            parsedBody = JSON.parse(body);\n          } catch (e) {\n            throw new Error(`Error parsing response from Apollo servers: ${e}`);\n          }\n          if (parsedBody.tracesIgnored === true) {\n            logger.debug(\n              \"This graph's organization does not have access to traces; sending all \" +\n                'subsequent operations as traces.',\n            );\n            graphMightSupportTraces = false;\n            // XXX We could also parse traces that are already in the current\n            // report and convert them to stats if we wanted?\n          }\n        }\n        if (options.debugPrintReports) {\n          // In terms of verbosity, and as the name of this option suggests, this\n          // message is either an \"info\" or a \"debug\" level message.  However,\n          // we are using `warn` here for compatibility reasons since the\n          // `debugPrintReports` flag pre-dated the existence of log-levels and\n          // changing this to also require `debug: true` (in addition to\n          // `debugPrintReports`) just to reach the level of verbosity to produce\n          // the output would be a breaking change.  The \"warn\" level is on by\n          // default.  There is a similar theory and comment applied above.\n          logger.warn(`Apollo usage report: status ${response.status}`);\n        }\n      };\n\n      requestDidStartHandler = ({\n        logger: requestLogger,\n        metrics,\n        schema,\n        request: { http, variables },\n      }): GraphQLRequestListener<TContext> => {\n        // Request specific log output should go into the `logger` from the\n        // request context when it's provided.\n        const logger = requestLogger ?? options.logger ?? serverLogger;\n        const treeBuilder: TraceTreeBuilder = new TraceTreeBuilder({\n          rewriteError: options.rewriteError,\n          logger,\n        });\n        treeBuilder.startTiming();\n        metrics.startHrTime = treeBuilder.startHrTime;\n        let graphqlValidationFailure = false;\n        let graphqlUnknownOperationName = false;\n        let includeOperationInUsageReporting: boolean | null = null;\n\n        if (http) {\n          treeBuilder.trace.http = new Trace.HTTP({\n            method:\n              Trace.HTTP.Method[\n                http.method as keyof typeof Trace.HTTP.Method\n              ] || Trace.HTTP.Method.UNKNOWN,\n          });\n\n          if (options.sendHeaders) {\n            makeHTTPRequestHeaders(\n              treeBuilder.trace.http,\n              http.headers,\n              options.sendHeaders,\n            );\n          }\n        }\n\n        // After this function completes, includeOperationInUsageReporting is\n        // defined.\n        async function maybeCallIncludeRequestHook(\n          requestContext:\n            | GraphQLRequestContextDidResolveOperation<TContext>\n            | GraphQLRequestContextWillSendResponse<TContext>,\n        ): Promise<void> {\n          // If this is the second call in `willSendResponse` after\n          // `didResolveOperation`, we're done.\n          if (includeOperationInUsageReporting !== null) return;\n\n          if (typeof options.includeRequest !== 'function') {\n            // Default case we always report\n            includeOperationInUsageReporting = true;\n            return;\n          }\n          includeOperationInUsageReporting = await options.includeRequest(\n            requestContext,\n          );\n\n          // Help the user understand they've returned an unexpected value,\n          // which might be a subtle mistake.\n          if (typeof includeOperationInUsageReporting !== 'boolean') {\n            logger.warn(\n              \"The 'includeRequest' async predicate function must return a boolean value.\",\n            );\n            includeOperationInUsageReporting = true;\n          }\n        }\n\n        // Our usage reporting groups everything by operation, so we don't\n        // actually report about any issues that prevent us from getting an\n        // operation string (eg, a missing operation, or APQ problems).\n        // This is effectively bypassing the reporting of:\n        //   - PersistedQueryNotFoundError\n        //   - PersistedQueryNotSupportedError\n        //   - Missing `query` error\n        // We may want to report them some other way later!\n        let didResolveSource: boolean = false;\n\n        return {\n          async didResolveSource(requestContext) {\n            didResolveSource = true;\n\n            if (metrics.persistedQueryHit) {\n              treeBuilder.trace.persistedQueryHit = true;\n            }\n            if (metrics.persistedQueryRegister) {\n              treeBuilder.trace.persistedQueryRegister = true;\n            }\n\n            if (variables) {\n              treeBuilder.trace.details = makeTraceDetails(\n                variables,\n                options.sendVariableValues,\n                requestContext.source,\n              );\n            }\n\n            const clientInfo = (\n              options.generateClientInfo || defaultGenerateClientInfo\n            )(requestContext);\n            if (clientInfo) {\n              // While there is a clientAddress protobuf field, the backend\n              // doesn't pay attention to it yet, so we'll ignore it for now.\n              const { clientName, clientVersion } = clientInfo;\n              treeBuilder.trace.clientVersion = clientVersion || '';\n              treeBuilder.trace.clientName = clientName || '';\n            }\n          },\n          async validationDidStart() {\n            return async (validationErrors?: ReadonlyArray<Error>) => {\n              graphqlValidationFailure = validationErrors\n                ? validationErrors.length !== 0\n                : false;\n            };\n          },\n          async didResolveOperation(requestContext) {\n            // If operation is undefined then `getOperationAST` returned null\n            // and an unknown operation was specified.\n            graphqlUnknownOperationName =\n              requestContext.operation === undefined;\n            await maybeCallIncludeRequestHook(requestContext);\n\n            if (\n              includeOperationInUsageReporting &&\n              // No need to capture traces if the operation is going to\n              // immediately fail due to unknown operation name.\n              !graphqlUnknownOperationName\n            ) {\n              if (metrics.captureTraces === undefined) {\n                // We're not completely ignoring the operation. But should we\n                // calculate a detailed trace of every field while we do so (either\n                // directly in this plugin, or in a subgraph by sending the\n                // apollo-federation-include-trace header)? That will allow this\n                // operation to contribute to the \"field executions\" column in the\n                // Studio Fields page, to the timing hints in Explorer and\n                // vscode-graphql, and to the traces visible under Operations. (Note\n                // that `true` here does not imply that this operation will\n                // necessarily be *sent* to the usage-reporting endpoint in the form\n                // of a trace --- it still might be aggregated into stats first. But\n                // capturing a trace will mean we can understand exactly what fields\n                // were executed and what their performance was, at the tradeoff of\n                // some overhead for tracking the trace (and transmitting it between\n                // subgraph and gateway).\n                const rawWeight = await fieldLevelInstrumentation(\n                  requestContext,\n                );\n                treeBuilder.trace.fieldExecutionWeight =\n                  typeof rawWeight === 'number' ? rawWeight : rawWeight ? 1 : 0;\n\n                metrics.captureTraces =\n                  !!treeBuilder.trace.fieldExecutionWeight;\n              }\n            }\n          },\n          async executionDidStart() {\n            // If we're not capturing traces, don't return a willResolveField so\n            // that we don't build up a detailed trace inside treeBuilder. (We still\n            // will use treeBuilder as a convenient place to put top-level facts\n            // about the operation which can end up aggregated as stats, and we do\n            // eventually put *errors* onto the trace tree.)\n            if (!metrics.captureTraces) return;\n\n            return {\n              willResolveField({ info }) {\n                return treeBuilder.willResolveField(info);\n                // We could save the error into the trace during the end handler, but\n                // it won't have all the information that graphql-js adds to it later,\n                // like 'locations'.\n              },\n            };\n          },\n          async willSendResponse(requestContext) {\n            // Search above for a comment about \"didResolveSource\" to see which\n            // of the pre-source-resolution errors we are intentionally avoiding.\n            if (!didResolveSource) return;\n            if (requestContext.errors) {\n              treeBuilder.didEncounterErrors(requestContext.errors);\n            }\n\n            const resolvedOperation = !!requestContext.operation;\n\n            // If we got an error before we called didResolveOperation (eg parse or\n            // validation error), check to see if we should include the request.\n            await maybeCallIncludeRequestHook(requestContext);\n\n            treeBuilder.stopTiming();\n            const executableSchemaId =\n              overriddenExecutableSchemaId ??\n              executableSchemaIdForSchema(schema);\n\n            if (includeOperationInUsageReporting === false) {\n              if (resolvedOperation)\n                getReportWhichMustBeUsedImmediately(executableSchemaId)\n                  .operationCount++;\n              return;\n            }\n\n            treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;\n            treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;\n            treeBuilder.trace.registeredOperation =\n              !!metrics.registeredOperation;\n\n            const policyIfCacheable =\n              requestContext.overallCachePolicy.policyIfCacheable();\n            if (policyIfCacheable) {\n              treeBuilder.trace.cachePolicy = new Trace.CachePolicy({\n                scope:\n                  policyIfCacheable.scope === CacheScope.Private\n                    ? Trace.CachePolicy.Scope.PRIVATE\n                    : policyIfCacheable.scope === CacheScope.Public\n                    ? Trace.CachePolicy.Scope.PUBLIC\n                    : Trace.CachePolicy.Scope.UNKNOWN,\n                // Convert from seconds to ns.\n                maxAgeNs: policyIfCacheable.maxAge * 1e9,\n              });\n            }\n\n            // If this was a federated operation and we're the gateway, add the query plan\n            // to the trace.\n            if (metrics.queryPlanTrace) {\n              treeBuilder.trace.queryPlan = metrics.queryPlanTrace;\n            }\n\n            // Intentionally un-awaited so as not to block the response.  Any\n            // errors will be logged, but will not manifest a user-facing error.\n            // The logger in this case is a request specific logger OR the logger\n            // defined by the plugin if that's unavailable.  The request-specific\n            // logger is preferred since this is very much coupled directly to a\n            // client-triggered action which might be more granularly tagged by\n            // logging implementations.\n            addTrace().catch(logger.error);\n\n            async function addTrace(): Promise<void> {\n              // Ignore traces that come in after stop().\n              if (stopped) {\n                return;\n              }\n\n              // Ensure that the caller of addTrace (which does not await it) is\n              // not blocked. We use setImmediate rather than process.nextTick or\n              // just relying on the Promise microtask queue because setImmediate\n              // comes after IO, which is what we want.\n              await new Promise((res) => setImmediate(res));\n\n              const executableSchemaId =\n                overriddenExecutableSchemaId ??\n                executableSchemaIdForSchema(schema);\n\n              const { trace } = treeBuilder;\n\n              let statsReportKey: string | undefined = undefined;\n              let referencedFieldsByType: ReferencedFieldsByType;\n              if (!requestContext.document) {\n                statsReportKey = `## GraphQLParseFailure\\n`;\n              } else if (graphqlValidationFailure) {\n                statsReportKey = `## GraphQLValidationFailure\\n`;\n              } else if (graphqlUnknownOperationName) {\n                statsReportKey = `## GraphQLUnknownOperationName\\n`;\n              }\n\n              const isExecutable = statsReportKey === undefined;\n\n              if (statsReportKey) {\n                if (options.sendUnexecutableOperationDocuments) {\n                  trace.unexecutedOperationBody = requestContext.source;\n                  // Get the operation name from the request (which might not\n                  // correspond to an actual operation).\n                  trace.unexecutedOperationName =\n                    requestContext.request.operationName || '';\n                }\n                referencedFieldsByType = Object.create(null);\n              } else {\n                const operationDerivedData = getOperationDerivedData();\n                statsReportKey = `# ${requestContext.operationName || '-'}\\n${\n                  operationDerivedData.signature\n                }`;\n                referencedFieldsByType =\n                  operationDerivedData.referencedFieldsByType;\n              }\n\n              const protobufError = Trace.verify(trace);\n              if (protobufError) {\n                throw new Error(`Error encoding trace: ${protobufError}`);\n              }\n\n              if (resolvedOperation) {\n                getReportWhichMustBeUsedImmediately(executableSchemaId)\n                  .operationCount++;\n              }\n\n              getReportWhichMustBeUsedImmediately(executableSchemaId).addTrace({\n                statsReportKey,\n                trace,\n                // We include the operation as a trace (rather than aggregated\n                // into stats) only if we believe it's possible that our\n                // organization's plan allows for viewing traces *and* we\n                // actually captured this as a full trace *and*\n                // sendOperationAsTrace says so.\n                //\n                // (As an edge case, if the reason metrics.captureTraces is\n                // falsey is that this is an unexecutable operation and thus we\n                // never ran the code in didResolveOperation that sets\n                // metrics.captureTrace, we allow it to be sent as a trace. This\n                // means we'll still send some parse and validation failures as\n                // traces, for the sake of the Errors page.)\n                asTrace:\n                  graphMightSupportTraces &&\n                  (!isExecutable || !!metrics.captureTraces) &&\n                  sendOperationAsTrace(trace, statsReportKey),\n                includeTracesContributingToStats,\n                referencedFieldsByType,\n              });\n\n              // If the buffer gets big (according to our estimate), send.\n              if (\n                sendReportsImmediately ||\n                getReportWhichMustBeUsedImmediately(executableSchemaId)\n                  .sizeEstimator.bytes >=\n                  (options.maxUncompressedReportSize || 4 * 1024 * 1024)\n              ) {\n                await sendReportAndReportErrors(executableSchemaId);\n              }\n            }\n\n            // Calculates signature and referenced fields for the current document.\n            // Only call this when the document properly parses and validates and\n            // the given operation name (if any) is known!\n            function getOperationDerivedData(): OperationDerivedData {\n              if (!requestContext.document) {\n                // This shouldn't happen: no document means parse failure, which\n                // uses its own special statsReportKey.\n                throw new Error('No document?');\n              }\n\n              const cacheKey = operationDerivedDataCacheKey(\n                requestContext.queryHash,\n                requestContext.operationName || '',\n              );\n\n              // Ensure that the cache we have is for the right schema.\n              if (\n                !operationDerivedDataCache ||\n                operationDerivedDataCache.forSchema !== schema\n              ) {\n                operationDerivedDataCache = {\n                  forSchema: schema,\n                  cache: createOperationDerivedDataCache({ logger }),\n                };\n              }\n\n              // If we didn't have the signature in the cache, we'll resort to\n              // calculating it.\n              const cachedOperationDerivedData =\n                operationDerivedDataCache.cache.get(cacheKey);\n              if (cachedOperationDerivedData) {\n                return cachedOperationDerivedData;\n              }\n\n              const generatedSignature = (\n                options.calculateSignature || usageReportingSignature\n              )(requestContext.document, requestContext.operationName || '');\n\n              const generatedOperationDerivedData: OperationDerivedData = {\n                signature: generatedSignature,\n                referencedFieldsByType: calculateReferencedFieldsByType({\n                  document: requestContext.document,\n                  schema,\n                  resolvedOperationName: requestContext.operationName ?? null,\n                }),\n              };\n\n              // Note that this cache is always an in-memory cache.\n              // If we replace it with a more generic async cache, we should\n              // not await the write operation.\n              operationDerivedDataCache.cache.set(\n                cacheKey,\n                generatedOperationDerivedData,\n              );\n              return generatedOperationDerivedData;\n            }\n          },\n        };\n      };\n\n      return {\n        async serverWillStop() {\n          if (reportTimer) {\n            clearInterval(reportTimer);\n            reportTimer = undefined;\n          }\n\n          stopped = true;\n          await sendAllReportsAndReportErrors();\n        },\n      };\n    },\n  };\n}\n\nexport function makeHTTPRequestHeaders(\n  http: Trace.IHTTP,\n  headers: Headers,\n  sendHeaders?: SendValuesBaseOptions,\n): void {\n  if (\n    !sendHeaders ||\n    ('none' in sendHeaders && sendHeaders.none) ||\n    ('all' in sendHeaders && !sendHeaders.all)\n  ) {\n    return;\n  }\n  for (const [key, value] of headers) {\n    const lowerCaseKey = key.toLowerCase();\n    if (\n      ('exceptNames' in sendHeaders &&\n        // We assume that most users only have a few headers to hide, or will\n        // just set {none: true} ; we can change this linear-time\n        // operation if it causes real performance issues.\n        sendHeaders.exceptNames.some((exceptHeader) => {\n          // Headers are case-insensitive, and should be compared as such.\n          return exceptHeader.toLowerCase() === lowerCaseKey;\n        })) ||\n      ('onlyNames' in sendHeaders &&\n        !sendHeaders.onlyNames.some((header) => {\n          return header.toLowerCase() === lowerCaseKey;\n        }))\n    ) {\n      continue;\n    }\n\n    switch (key) {\n      case 'authorization':\n      case 'cookie':\n      case 'set-cookie':\n        break;\n      default:\n        http!.requestHeaders![key] = new Trace.HTTP.Values({\n          value: [value],\n        });\n    }\n  }\n}\n\nfunction defaultGenerateClientInfo({ request }: GraphQLRequestContext) {\n  const clientNameHeaderKey = 'apollographql-client-name';\n  const clientVersionHeaderKey = 'apollographql-client-version';\n\n  // Default to using the `apollo-client-x` header fields if present.\n  // If none are present, fallback on the `clientInfo` query extension\n  // for backwards compatibility.\n  // The default value if neither header values nor query extension is\n  // set is the empty String for all fields (as per protobuf defaults)\n  if (\n    request.http?.headers?.get(clientNameHeaderKey) ||\n    request.http?.headers?.get(clientVersionHeaderKey)\n  ) {\n    return {\n      clientName: request.http?.headers?.get(clientNameHeaderKey),\n      clientVersion: request.http?.headers?.get(clientVersionHeaderKey),\n    };\n  } else if (request.extensions?.clientInfo) {\n    return request.extensions.clientInfo;\n  } else {\n    return {};\n  }\n}\n\n// This plugin does nothing, but it ensures that ApolloServer won't try\n// to add a default ApolloServerPluginUsageReporting.\nexport function ApolloServerPluginUsageReportingDisabled(): InternalApolloServerPlugin {\n  return {\n    __internal_plugin_id__() {\n      return 'UsageReporting';\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}