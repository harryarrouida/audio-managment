{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.processGraphQLRequest = exports.APQ_CACHE_PREFIX = void 0;\nconst graphql_1 = require(\"graphql\");\nconst schemaInstrumentation_1 = require(\"./utils/schemaInstrumentation\");\nconst apollo_server_errors_1 = require(\"apollo-server-errors\");\nconst dispatcher_1 = require(\"./utils/dispatcher\");\nconst utils_keyvaluecache_1 = require(\"@apollo/utils.keyvaluecache\");\nconst createSHA_1 = __importDefault(require(\"./utils/createSHA\"));\nconst runHttpQuery_1 = require(\"./runHttpQuery\");\nconst apollo_server_env_1 = require(\"apollo-server-env\");\nexports.APQ_CACHE_PREFIX = 'apq:';\nfunction computeQueryHash(query) {\n  return (0, createSHA_1.default)('sha256').update(query).digest('hex');\n}\nfunction isBadUserInputGraphQLError(error) {\n  var _a;\n  return ((_a = error.nodes) === null || _a === void 0 ? void 0 : _a.length) === 1 && error.nodes[0].kind === graphql_1.Kind.VARIABLE_DEFINITION && (error.message.startsWith(`Variable \"$${error.nodes[0].variable.name.value}\" got invalid value `) || error.message.startsWith(`Variable \"$${error.nodes[0].variable.name.value}\" of required type `) || error.message.startsWith(`Variable \"$${error.nodes[0].variable.name.value}\" of non-null type `));\n}\nasync function processGraphQLRequest(config, requestContext) {\n  var _a, _b;\n  const logger = requestContext.logger || console;\n  const metrics = requestContext.metrics = requestContext.metrics || Object.create(null);\n  const dispatcher = await initializeRequestListenerDispatcher();\n  await initializeDataSources();\n  const request = requestContext.request;\n  let {\n    query,\n    extensions\n  } = request;\n  let queryHash;\n  let persistedQueryCache;\n  metrics.persistedQueryHit = false;\n  metrics.persistedQueryRegister = false;\n  if (extensions === null || extensions === void 0 ? void 0 : extensions.persistedQuery) {\n    if (!config.persistedQueries || !config.persistedQueries.cache) {\n      return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotSupportedError());\n    } else if (extensions.persistedQuery.version !== 1) {\n      return await sendErrorResponse(new graphql_1.GraphQLError('Unsupported persisted query version'));\n    }\n    persistedQueryCache = config.persistedQueries.cache;\n    if (!(persistedQueryCache instanceof utils_keyvaluecache_1.PrefixingKeyValueCache)) {\n      persistedQueryCache = new utils_keyvaluecache_1.PrefixingKeyValueCache(persistedQueryCache, exports.APQ_CACHE_PREFIX);\n    }\n    queryHash = extensions.persistedQuery.sha256Hash;\n    if (query === undefined) {\n      query = await persistedQueryCache.get(queryHash);\n      if (query) {\n        metrics.persistedQueryHit = true;\n      } else {\n        return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotFoundError());\n      }\n    } else {\n      const computedQueryHash = computeQueryHash(query);\n      if (queryHash !== computedQueryHash) {\n        return await sendErrorResponse(new graphql_1.GraphQLError('provided sha does not match query'));\n      }\n      metrics.persistedQueryRegister = true;\n    }\n  } else if (query) {\n    queryHash = computeQueryHash(query);\n  } else {\n    return await sendErrorResponse(new graphql_1.GraphQLError('GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.'));\n  }\n  requestContext.queryHash = queryHash;\n  requestContext.source = query;\n  await dispatcher.invokeHook('didResolveSource', requestContext);\n  if (config.documentStore) {\n    try {\n      requestContext.document = await config.documentStore.get(queryHash);\n    } catch (err) {\n      logger.warn('An error occurred while attempting to read from the documentStore. ' + (err === null || err === void 0 ? void 0 : err.message) || err);\n    }\n  }\n  if (!requestContext.document) {\n    const parsingDidEnd = await dispatcher.invokeDidStartHook('parsingDidStart', requestContext);\n    try {\n      requestContext.document = parse(query, config.parseOptions);\n      await parsingDidEnd();\n    } catch (syntaxError) {\n      await parsingDidEnd(syntaxError);\n      return await sendErrorResponse(syntaxError, apollo_server_errors_1.SyntaxError);\n    }\n    if (config.dangerouslyDisableValidation !== true) {\n      const validationDidEnd = await dispatcher.invokeDidStartHook('validationDidStart', requestContext);\n      const validationErrors = validate(requestContext.document);\n      if (validationErrors.length === 0) {\n        await validationDidEnd();\n      } else {\n        await validationDidEnd(validationErrors);\n        return await sendErrorResponse(validationErrors, apollo_server_errors_1.ValidationError);\n      }\n    }\n    if (config.documentStore) {\n      Promise.resolve(config.documentStore.set(queryHash, requestContext.document)).catch(err => logger.warn('Could not store validated document. ' + (err === null || err === void 0 ? void 0 : err.message) || err));\n    }\n  }\n  const operation = (0, graphql_1.getOperationAST)(requestContext.document, request.operationName);\n  requestContext.operation = operation || undefined;\n  requestContext.operationName = ((_a = operation === null || operation === void 0 ? void 0 : operation.name) === null || _a === void 0 ? void 0 : _a.value) || null;\n  try {\n    await dispatcher.invokeHook('didResolveOperation', requestContext);\n  } catch (err) {\n    return await sendErrorResponse(err);\n  }\n  if (metrics.persistedQueryRegister && persistedQueryCache) {\n    Promise.resolve(persistedQueryCache.set(queryHash, query, config.persistedQueries && typeof config.persistedQueries.ttl !== 'undefined' ? {\n      ttl: config.persistedQueries.ttl\n    } : Object.create(null))).catch(logger.warn);\n  }\n  let response = await dispatcher.invokeHooksUntilNonNull('responseForOperation', requestContext);\n  if (response == null) {\n    const executionListeners = [];\n    (await dispatcher.invokeHook('executionDidStart', requestContext)).forEach(executionListener => {\n      if (executionListener) {\n        executionListeners.push(executionListener);\n      }\n    });\n    executionListeners.reverse();\n    const executionDispatcher = new dispatcher_1.Dispatcher(executionListeners);\n    if (executionDispatcher.hasHook('willResolveField')) {\n      const invokeWillResolveField = (...args) => executionDispatcher.invokeSyncDidStartHook('willResolveField', ...args);\n      Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolExecutionDispatcherWillResolveField, {\n        value: invokeWillResolveField\n      });\n      if (config.fieldResolver) {\n        Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolUserFieldResolver, {\n          value: config.fieldResolver\n        });\n      }\n      (0, schemaInstrumentation_1.enablePluginsForSchemaResolvers)(config.schema);\n    }\n    try {\n      const result = await execute(requestContext);\n      const resultErrors = (_b = result.errors) === null || _b === void 0 ? void 0 : _b.map(e => {\n        if (isBadUserInputGraphQLError(e)) {\n          return (0, apollo_server_errors_1.fromGraphQLError)(e, {\n            errorClass: apollo_server_errors_1.UserInputError\n          });\n        }\n        return e;\n      });\n      if (resultErrors) {\n        await didEncounterErrors(resultErrors);\n      }\n      response = {\n        ...result,\n        errors: resultErrors ? formatErrors(resultErrors) : undefined\n      };\n      await executionDispatcher.invokeHook('executionDidEnd');\n    } catch (executionError) {\n      await executionDispatcher.invokeHook('executionDidEnd', executionError);\n      return await sendErrorResponse(executionError);\n    }\n  }\n  if (config.formatResponse) {\n    const formattedResponse = config.formatResponse(response, requestContext);\n    if (formattedResponse != null) {\n      response = formattedResponse;\n    }\n  }\n  return sendResponse(response);\n  function parse(query, parseOptions) {\n    return (0, graphql_1.parse)(query, parseOptions);\n  }\n  function validate(document) {\n    let rules = graphql_1.specifiedRules;\n    if (config.validationRules) {\n      rules = rules.concat(config.validationRules);\n    }\n    return (0, graphql_1.validate)(config.schema, document, rules);\n  }\n  async function execute(requestContext) {\n    const {\n      request,\n      document\n    } = requestContext;\n    const executionArgs = {\n      schema: config.schema,\n      document,\n      rootValue: typeof config.rootValue === 'function' ? config.rootValue(document) : config.rootValue,\n      contextValue: requestContext.context,\n      variableValues: request.variables,\n      operationName: request.operationName,\n      fieldResolver: config.fieldResolver\n    };\n    if (config.executor) {\n      return await config.executor(requestContext);\n    } else {\n      return await (0, graphql_1.execute)(executionArgs);\n    }\n  }\n  async function sendResponse(response) {\n    requestContext.response = {\n      ...requestContext.response,\n      errors: response.errors,\n      data: response.data,\n      extensions: response.extensions\n    };\n    if (response.http) {\n      if (!requestContext.response.http) {\n        requestContext.response.http = {\n          headers: new apollo_server_env_1.Headers()\n        };\n      }\n      if (response.http.status) {\n        requestContext.response.http.status = response.http.status;\n      }\n      for (const [name, value] of response.http.headers) {\n        requestContext.response.http.headers.set(name, value);\n      }\n    }\n    await dispatcher.invokeHook('willSendResponse', requestContext);\n    return requestContext.response;\n  }\n  async function didEncounterErrors(errors) {\n    requestContext.errors = errors;\n    return await dispatcher.invokeHook('didEncounterErrors', requestContext);\n  }\n  async function sendErrorResponse(errorOrErrors, errorClass) {\n    const errors = Array.isArray(errorOrErrors) ? errorOrErrors : [errorOrErrors];\n    await didEncounterErrors(errors);\n    const response = {\n      errors: formatErrors(errors.map(err => err instanceof apollo_server_errors_1.ApolloError && !errorClass ? err : (0, apollo_server_errors_1.fromGraphQLError)(err, errorClass && {\n        errorClass\n      })))\n    };\n    if (errors.every(err => err instanceof apollo_server_errors_1.PersistedQueryNotSupportedError || err instanceof apollo_server_errors_1.PersistedQueryNotFoundError)) {\n      response.http = {\n        status: 200,\n        headers: new apollo_server_env_1.Headers({\n          'Cache-Control': 'private, no-cache, must-revalidate'\n        })\n      };\n    } else if (errors.length === 1 && errors[0] instanceof runHttpQuery_1.HttpQueryError) {\n      response.http = {\n        status: errors[0].statusCode,\n        headers: new apollo_server_env_1.Headers(errors[0].headers)\n      };\n    }\n    return sendResponse(response);\n  }\n  function formatErrors(errors) {\n    return (0, apollo_server_errors_1.formatApolloErrors)(errors, {\n      formatter: config.formatError,\n      debug: requestContext.debug\n    });\n  }\n  async function initializeRequestListenerDispatcher() {\n    const requestListeners = [];\n    if (config.plugins) {\n      for (const plugin of config.plugins) {\n        if (!plugin.requestDidStart) continue;\n        const listener = await plugin.requestDidStart(requestContext);\n        if (listener) {\n          requestListeners.push(listener);\n        }\n      }\n    }\n    return new dispatcher_1.Dispatcher(requestListeners);\n  }\n  async function initializeDataSources() {\n    if (config.dataSources) {\n      const context = requestContext.context;\n      const dataSources = config.dataSources();\n      const initializers = [];\n      for (const dataSource of Object.values(dataSources)) {\n        if (dataSource.initialize) {\n          initializers.push(dataSource.initialize({\n            context,\n            cache: requestContext.cache\n          }));\n        }\n      }\n      await Promise.all(initializers);\n      if ('dataSources' in context) {\n        throw new Error('Please use the dataSources config option instead of putting dataSources on the context yourself.');\n      }\n      context.dataSources = dataSources;\n    }\n  }\n}\nexports.processGraphQLRequest = processGraphQLRequest;","map":{"version":3,"names":["graphql_1","require","schemaInstrumentation_1","apollo_server_errors_1","dispatcher_1","utils_keyvaluecache_1","createSHA_1","__importDefault","runHttpQuery_1","apollo_server_env_1","exports","APQ_CACHE_PREFIX","computeQueryHash","query","default","update","digest","isBadUserInputGraphQLError","error","_a","nodes","length","kind","Kind","VARIABLE_DEFINITION","message","startsWith","variable","name","value","processGraphQLRequest","config","requestContext","logger","console","metrics","Object","create","dispatcher","initializeRequestListenerDispatcher","initializeDataSources","request","extensions","queryHash","persistedQueryCache","persistedQueryHit","persistedQueryRegister","persistedQuery","persistedQueries","cache","sendErrorResponse","PersistedQueryNotSupportedError","version","GraphQLError","PrefixingKeyValueCache","sha256Hash","undefined","get","PersistedQueryNotFoundError","computedQueryHash","source","invokeHook","documentStore","document","err","warn","parsingDidEnd","invokeDidStartHook","parse","parseOptions","syntaxError","SyntaxError","dangerouslyDisableValidation","validationDidEnd","validationErrors","validate","ValidationError","Promise","resolve","set","catch","operation","getOperationAST","operationName","ttl","response","invokeHooksUntilNonNull","executionListeners","forEach","executionListener","push","reverse","executionDispatcher","Dispatcher","hasHook","invokeWillResolveField","args","invokeSyncDidStartHook","defineProperty","context","symbolExecutionDispatcherWillResolveField","fieldResolver","symbolUserFieldResolver","enablePluginsForSchemaResolvers","schema","result","execute","resultErrors","_b","errors","map","e","fromGraphQLError","errorClass","UserInputError","didEncounterErrors","formatErrors","executionError","formatResponse","formattedResponse","sendResponse","rules","specifiedRules","validationRules","concat","executionArgs","rootValue","contextValue","variableValues","variables","executor","data","http","headers","Headers","status","errorOrErrors","Array","isArray","ApolloError","every","HttpQueryError","statusCode","formatApolloErrors","formatter","formatError","debug","requestListeners","plugins","plugin","requestDidStart","listener","dataSources","initializers","dataSource","values","initialize","all","Error"],"sources":["C:\\Users\\Hamza Arrouida\\Desktop\\PROJECTS\\SNRT\\audio-managment-v2 [enhanced]\\node_modules\\apollo-server-core\\src\\requestPipeline.ts"],"sourcesContent":["import {\n  GraphQLSchema,\n  GraphQLFieldResolver,\n  specifiedRules,\n  DocumentNode,\n  getOperationAST,\n  ExecutionArgs,\n  GraphQLError,\n  GraphQLFormattedError,\n  validate as graphqlValidate,\n  parse as graphqlParse,\n  execute as graphqlExecute,\n  Kind,\n  ParseOptions,\n} from 'graphql';\nimport type { DataSource } from 'apollo-datasource';\nimport type { PersistedQueryOptions } from './graphqlOptions';\nimport {\n  symbolExecutionDispatcherWillResolveField,\n  enablePluginsForSchemaResolvers,\n  symbolUserFieldResolver,\n} from './utils/schemaInstrumentation';\nimport {\n  ApolloError,\n  fromGraphQLError,\n  SyntaxError,\n  ValidationError,\n  PersistedQueryNotSupportedError,\n  PersistedQueryNotFoundError,\n  formatApolloErrors,\n  UserInputError,\n} from 'apollo-server-errors';\nimport type {\n  GraphQLRequest,\n  GraphQLResponse,\n  GraphQLRequestContext,\n  GraphQLExecutor,\n  GraphQLExecutionResult,\n  ValidationRule,\n  BaseContext,\n} from 'apollo-server-types';\nimport type {\n  ApolloServerPlugin,\n  GraphQLRequestListener,\n  GraphQLRequestContextDidResolveSource,\n  GraphQLRequestContextExecutionDidStart,\n  GraphQLRequestContextResponseForOperation,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextParsingDidStart,\n  GraphQLRequestContextValidationDidStart,\n  GraphQLRequestContextWillSendResponse,\n  GraphQLRequestContextDidEncounterErrors,\n  GraphQLRequestExecutionListener,\n} from 'apollo-server-plugin-base';\n\nimport { Dispatcher } from './utils/dispatcher';\nimport {\n  KeyValueCache,\n  PrefixingKeyValueCache,\n} from '@apollo/utils.keyvaluecache';\n\nexport { GraphQLRequest, GraphQLResponse, GraphQLRequestContext };\n\nimport createSHA from './utils/createSHA';\nimport { HttpQueryError } from './runHttpQuery';\nimport type { DocumentStore } from './types';\nimport { Headers } from 'apollo-server-env';\n\nexport const APQ_CACHE_PREFIX = 'apq:';\n\nfunction computeQueryHash(query: string) {\n  return createSHA('sha256').update(query).digest('hex');\n}\n\nexport interface GraphQLRequestPipelineConfig<TContext> {\n  schema: GraphQLSchema;\n\n  rootValue?: ((document: DocumentNode) => any) | any;\n  validationRules?: ValidationRule[];\n  executor?: GraphQLExecutor;\n  fieldResolver?: GraphQLFieldResolver<any, TContext>;\n\n  dataSources?: () => DataSources<TContext>;\n\n  persistedQueries?: PersistedQueryOptions;\n\n  formatError?: (error: GraphQLError) => GraphQLFormattedError;\n  formatResponse?: (\n    response: GraphQLResponse,\n    requestContext: GraphQLRequestContext<TContext>,\n  ) => GraphQLResponse | null;\n\n  plugins?: ApolloServerPlugin[];\n  dangerouslyDisableValidation?: boolean;\n  documentStore?: DocumentStore | null;\n\n  parseOptions?: ParseOptions;\n}\n\nexport type DataSources<TContext> = {\n  [name: string]: DataSource<TContext>;\n};\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\nfunction isBadUserInputGraphQLError(error: GraphQLError): Boolean {\n  return (\n    error.nodes?.length === 1 &&\n    error.nodes[0].kind === Kind.VARIABLE_DEFINITION &&\n    (error.message.startsWith(\n      `Variable \"$${error.nodes[0].variable.name.value}\" got invalid value `,\n    ) ||\n      error.message.startsWith(\n        `Variable \"$${error.nodes[0].variable.name.value}\" of required type `,\n      ) ||\n      error.message.startsWith(\n        `Variable \"$${error.nodes[0].variable.name.value}\" of non-null type `,\n      ))\n  );\n}\n\nexport async function processGraphQLRequest<TContext extends BaseContext>(\n  config: GraphQLRequestPipelineConfig<TContext>,\n  requestContext: Mutable<GraphQLRequestContext<TContext>>,\n): Promise<GraphQLResponse> {\n  // For legacy reasons, this exported method may exist without a `logger` on\n  // the context.  We'll need to make sure we account for that, even though\n  // all of our own machinery will certainly set it now.\n  const logger = requestContext.logger || console;\n\n  // If request context's `metrics` already exists, preserve it, but _ensure_ it\n  // exists there and shorthand it for use throughout this function.\n  const metrics = (requestContext.metrics =\n    requestContext.metrics || Object.create(null));\n\n  const dispatcher = await initializeRequestListenerDispatcher();\n  await initializeDataSources();\n\n  const request = requestContext.request;\n\n  let { query, extensions } = request;\n\n  let queryHash: string;\n\n  let persistedQueryCache: KeyValueCache | undefined;\n  metrics.persistedQueryHit = false;\n  metrics.persistedQueryRegister = false;\n\n  if (extensions?.persistedQuery) {\n    // It looks like we've received a persisted query. Check if we\n    // support them.\n    if (!config.persistedQueries || !config.persistedQueries.cache) {\n      return await sendErrorResponse(new PersistedQueryNotSupportedError());\n    } else if (extensions.persistedQuery.version !== 1) {\n      return await sendErrorResponse(\n        new GraphQLError('Unsupported persisted query version'),\n      );\n    }\n\n    // We'll store a reference to the persisted query cache so we can actually\n    // do the write at a later point in the request pipeline processing.\n    persistedQueryCache = config.persistedQueries.cache;\n\n    // This is a bit hacky, but if `config` came from direct use of the old\n    // apollo-server 1.0-style middleware (graphqlExpress etc, not via the\n    // ApolloServer class), it won't have been converted to\n    // PrefixingKeyValueCache yet.\n    if (!(persistedQueryCache instanceof PrefixingKeyValueCache)) {\n      persistedQueryCache = new PrefixingKeyValueCache(\n        persistedQueryCache,\n        APQ_CACHE_PREFIX,\n      );\n    }\n\n    queryHash = extensions.persistedQuery.sha256Hash;\n\n    if (query === undefined) {\n      query = await persistedQueryCache.get(queryHash);\n      if (query) {\n        metrics.persistedQueryHit = true;\n      } else {\n        return await sendErrorResponse(new PersistedQueryNotFoundError());\n      }\n    } else {\n      const computedQueryHash = computeQueryHash(query);\n\n      // The provided hash must exactly match the SHA-256 hash of\n      // the query string. This prevents hash hijacking, where a\n      // new and potentially malicious query is associated with\n      // an existing hash.\n      if (queryHash !== computedQueryHash) {\n        return await sendErrorResponse(\n          new GraphQLError('provided sha does not match query'),\n        );\n      }\n\n      // We won't write to the persisted query cache until later.\n      // Deferring the writing gives plugins the ability to \"win\" from use of\n      // the cache, but also have their say in whether or not the cache is\n      // written to (by interrupting the request with an error).\n      metrics.persistedQueryRegister = true;\n    }\n  } else if (query) {\n    // TODO: We'll compute the APQ query hash to use as our cache key for\n    // now, but this should be replaced with the new operation ID algorithm.\n    queryHash = computeQueryHash(query);\n  } else {\n    return await sendErrorResponse(\n      new GraphQLError(\n        'GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.',\n      ),\n    );\n  }\n\n  requestContext.queryHash = queryHash;\n  requestContext.source = query;\n\n  // Let the plugins know that we now have a STRING of what we hope will\n  // parse and validate into a document we can execute on.  Unless we have\n  // retrieved this from our APQ cache, there's no guarantee that it is\n  // syntactically correct, so this string should not be trusted as a valid\n  // document until after it's parsed and validated.\n  await dispatcher.invokeHook(\n    'didResolveSource',\n    requestContext as GraphQLRequestContextDidResolveSource<TContext>,\n  );\n\n  // If we're configured with a document store (by default, we are), we'll\n  // utilize the operation's hash to lookup the AST from the previously\n  // parsed-and-validated operation.  Failure to retrieve anything from the\n  // cache just means we're committed to doing the parsing and validation.\n  if (config.documentStore) {\n    try {\n      requestContext.document = await config.documentStore.get(queryHash);\n    } catch (err) {\n      logger.warn(\n        'An error occurred while attempting to read from the documentStore. ' +\n          (err as Error)?.message || err,\n      );\n    }\n  }\n\n  // If we still don't have a document, we'll need to parse and validate it.\n  // With success, we'll attempt to save it into the store for future use.\n  if (!requestContext.document) {\n    const parsingDidEnd = await dispatcher.invokeDidStartHook(\n      'parsingDidStart',\n      requestContext as GraphQLRequestContextParsingDidStart<TContext>,\n    );\n\n    try {\n      requestContext.document = parse(query, config.parseOptions);\n      await parsingDidEnd();\n    } catch (syntaxError) {\n      await parsingDidEnd(syntaxError as Error);\n      // XXX: This cast is pretty sketchy, as other error types can be thrown\n      // by parsingDidEnd!\n      return await sendErrorResponse(syntaxError as GraphQLError, SyntaxError);\n    }\n\n    if (config.dangerouslyDisableValidation !== true) {\n      const validationDidEnd = await dispatcher.invokeDidStartHook(\n        'validationDidStart',\n        requestContext as GraphQLRequestContextValidationDidStart<TContext>,\n      );\n\n      const validationErrors = validate(requestContext.document);\n\n      if (validationErrors.length === 0) {\n        await validationDidEnd();\n      } else {\n        await validationDidEnd(validationErrors);\n        return await sendErrorResponse(validationErrors, ValidationError);\n      }\n    }\n\n    if (config.documentStore) {\n      // The underlying cache store behind the `documentStore` returns a\n      // `Promise` which is resolved (or rejected), eventually, based on the\n      // success or failure (respectively) of the cache save attempt.  While\n      // it's certainly possible to `await` this `Promise`, we don't care about\n      // whether or not it's successful at this point.  We'll instead proceed\n      // to serve the rest of the request and just hope that this works out.\n      // If it doesn't work, the next request will have another opportunity to\n      // try again.  Errors will surface as warnings, as appropriate.\n      //\n      // While it shouldn't normally be necessary to wrap this `Promise` in a\n      // `Promise.resolve` invocation, it seems that the underlying cache store\n      // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n      Promise.resolve(\n        config.documentStore.set(queryHash, requestContext.document),\n      ).catch((err) =>\n        logger.warn(\n          'Could not store validated document. ' + err?.message || err,\n        ),\n      );\n    }\n  }\n\n  // TODO: If we want to guarantee an operation has been set when invoking\n  // `willExecuteOperation` and executionDidStart`, we need to throw an\n  // error here and not leave this to `buildExecutionContext` in\n  // `graphql-js`.\n  const operation = getOperationAST(\n    requestContext.document,\n    request.operationName,\n  );\n\n  requestContext.operation = operation || undefined;\n  // We'll set `operationName` to `null` for anonymous operations.\n  requestContext.operationName = operation?.name?.value || null;\n\n  try {\n    await dispatcher.invokeHook(\n      'didResolveOperation',\n      requestContext as GraphQLRequestContextDidResolveOperation<TContext>,\n    );\n  } catch (err) {\n    // XXX: This cast is pretty sketchy, as other error types can be thrown\n    // by didResolveOperation!\n    return await sendErrorResponse(err as GraphQLError);\n  }\n\n  // Now that we've gone through the pre-execution phases of the request\n  // pipeline, and given plugins appropriate ability to object (by throwing\n  // an error) and not actually write, we'll write to the cache if it was\n  // determined earlier in the request pipeline that we should do so.\n  if (metrics.persistedQueryRegister && persistedQueryCache) {\n    // While it shouldn't normally be necessary to wrap this `Promise` in a\n    // `Promise.resolve` invocation, it seems that the underlying cache store\n    // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n    Promise.resolve(\n      persistedQueryCache.set(\n        queryHash,\n        query,\n        config.persistedQueries &&\n          typeof config.persistedQueries.ttl !== 'undefined'\n          ? {\n              ttl: config.persistedQueries.ttl,\n            }\n          : Object.create(null),\n      ),\n    ).catch(logger.warn);\n  }\n\n  let response: GraphQLResponse | null =\n    await dispatcher.invokeHooksUntilNonNull(\n      'responseForOperation',\n      requestContext as GraphQLRequestContextResponseForOperation<TContext>,\n    );\n  if (response == null) {\n    // This execution dispatcher code is duplicated in `pluginTestHarness`\n    // right now.\n\n    const executionListeners: GraphQLRequestExecutionListener<TContext>[] = [];\n    (\n      await dispatcher.invokeHook(\n        'executionDidStart',\n        requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n      )\n    ).forEach((executionListener) => {\n      if (executionListener) {\n        executionListeners.push(executionListener);\n      }\n    });\n    executionListeners.reverse();\n\n    const executionDispatcher = new Dispatcher(executionListeners);\n\n    if (executionDispatcher.hasHook('willResolveField')) {\n      // Create a callback that will trigger the execution dispatcher's\n      // `willResolveField` hook.  We will attach this to the context on a\n      // symbol so it can be invoked by our `wrapField` method during execution.\n      const invokeWillResolveField: GraphQLRequestExecutionListener<TContext>['willResolveField'] =\n        (...args) =>\n          executionDispatcher.invokeSyncDidStartHook(\n            'willResolveField',\n            ...args,\n          );\n\n      Object.defineProperty(\n        requestContext.context,\n        symbolExecutionDispatcherWillResolveField,\n        { value: invokeWillResolveField },\n      );\n\n      // If the user has provided a custom field resolver, we will attach\n      // it to the context so we can still invoke it after we've wrapped the\n      // fields with `wrapField` within `enablePluginsForSchemaResolvers` of\n      // the `schemaInstrumentation` module.\n      if (config.fieldResolver) {\n        Object.defineProperty(requestContext.context, symbolUserFieldResolver, {\n          value: config.fieldResolver,\n        });\n      }\n\n      // If the schema is already enabled, this is a no-op.  Otherwise, the\n      // schema will be augmented so it is able to invoke willResolveField. Note\n      // that if we never see a plugin with willResolveField then we will never\n      // need to instrument the schema, which might be a small performance gain.\n      // (For example, this can happen if you pass `fieldLevelInstrumentation:\n      // () => false` to the usage reporting plugin and disable the cache\n      // control plugin. We can consider changing the cache control plugin to\n      // have a \"static cache control only\" mode that doesn't use\n      // willResolveField too if this proves to be helpful in practice.)\n      enablePluginsForSchemaResolvers(config.schema);\n    }\n\n    try {\n      const result = await execute(\n        requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n      );\n\n      // The first thing that execution does is coerce the request's variables\n      // to the types declared in the operation, which can lead to errors if\n      // they are of the wrong type. It also makes sure that all non-null\n      // variables are required and get non-null values. If any of these things\n      // lead to errors, we change them into UserInputError so that their code\n      // doesn't end up being INTERNAL_SERVER_ERROR, since these are client\n      // errors.\n      //\n      // This is hacky! Hopefully graphql-js will give us a way to separate\n      // variable resolution from execution later; see\n      // https://github.com/graphql/graphql-js/issues/3169\n      const resultErrors = result.errors?.map((e) => {\n        if (isBadUserInputGraphQLError(e)) {\n          return fromGraphQLError(e, {\n            errorClass: UserInputError,\n          });\n        }\n        return e;\n      });\n\n      if (resultErrors) {\n        await didEncounterErrors(resultErrors);\n      }\n\n      response = {\n        ...result,\n        errors: resultErrors ? formatErrors(resultErrors) : undefined,\n      };\n\n      await executionDispatcher.invokeHook('executionDidEnd');\n    } catch (executionError) {\n      await executionDispatcher.invokeHook(\n        'executionDidEnd',\n        executionError as Error,\n      );\n      // XXX: This cast is pretty sketchy, as other error types can be thrown\n      // in the try block!\n      return await sendErrorResponse(executionError as GraphQLError);\n    }\n  }\n\n  if (config.formatResponse) {\n    const formattedResponse: GraphQLResponse | null = config.formatResponse(\n      response,\n      requestContext,\n    );\n    if (formattedResponse != null) {\n      response = formattedResponse;\n    }\n  }\n\n  return sendResponse(response);\n\n  function parse(query: string, parseOptions?: ParseOptions): DocumentNode {\n    return graphqlParse(query, parseOptions);\n  }\n\n  function validate(document: DocumentNode): ReadonlyArray<GraphQLError> {\n    let rules = specifiedRules;\n    if (config.validationRules) {\n      rules = rules.concat(config.validationRules);\n    }\n\n    return graphqlValidate(config.schema, document, rules);\n  }\n\n  async function execute(\n    requestContext: GraphQLRequestContextExecutionDidStart<TContext>,\n  ): Promise<GraphQLExecutionResult> {\n    const { request, document } = requestContext;\n\n    const executionArgs: ExecutionArgs = {\n      schema: config.schema,\n      document,\n      rootValue:\n        typeof config.rootValue === 'function'\n          ? config.rootValue(document)\n          : config.rootValue,\n      contextValue: requestContext.context,\n      variableValues: request.variables,\n      operationName: request.operationName,\n      fieldResolver: config.fieldResolver,\n    };\n\n    if (config.executor) {\n      // XXX Nothing guarantees that the only errors thrown or returned\n      // in result.errors are GraphQLErrors, even though other code\n      // (eg usage reporting) assumes that.\n      return await config.executor(requestContext);\n    } else {\n      return await graphqlExecute(executionArgs);\n    }\n  }\n\n  async function sendResponse(\n    response: GraphQLResponse,\n  ): Promise<GraphQLResponse> {\n    requestContext.response = {\n      ...requestContext.response,\n      errors: response.errors,\n      data: response.data,\n      extensions: response.extensions,\n    };\n    if (response.http) {\n      if (!requestContext.response.http) {\n        requestContext.response.http = {\n          headers: new Headers(),\n        };\n      }\n      if (response.http.status) {\n        requestContext.response.http.status = response.http.status;\n      }\n      for (const [name, value] of response.http.headers) {\n        requestContext.response.http.headers.set(name, value);\n      }\n    }\n    await dispatcher.invokeHook(\n      'willSendResponse',\n      requestContext as GraphQLRequestContextWillSendResponse<TContext>,\n    );\n    return requestContext.response;\n  }\n\n  // Note that we ensure that all calls to didEncounterErrors are followed by\n  // calls to willSendResponse. (The usage reporting plugin depends on this.)\n  async function didEncounterErrors(errors: ReadonlyArray<GraphQLError>) {\n    requestContext.errors = errors;\n\n    return await dispatcher.invokeHook(\n      'didEncounterErrors',\n      requestContext as GraphQLRequestContextDidEncounterErrors<TContext>,\n    );\n  }\n\n  async function sendErrorResponse(\n    errorOrErrors: ReadonlyArray<GraphQLError> | GraphQLError,\n    errorClass?: typeof ApolloError,\n  ) {\n    // If a single error is passed, it should still be encapsulated in an array.\n    const errors = Array.isArray(errorOrErrors)\n      ? errorOrErrors\n      : [errorOrErrors];\n\n    await didEncounterErrors(errors);\n\n    const response: GraphQLResponse = {\n      errors: formatErrors(\n        errors.map((err) =>\n          err instanceof ApolloError && !errorClass\n            ? err\n            : fromGraphQLError(\n                err,\n                errorClass && {\n                  errorClass,\n                },\n              ),\n        ),\n      ),\n    };\n\n    // Persisted query errors (especially \"not found\") need to be uncached,\n    // because hopefully we're about to fill in the APQ cache and the same\n    // request will succeed next time. We also want a 200 response to avoid any\n    // error handling that may mask the contents of an error response.\n    if (\n      errors.every(\n        (err) =>\n          err instanceof PersistedQueryNotSupportedError ||\n          err instanceof PersistedQueryNotFoundError,\n      )\n    ) {\n      response.http = {\n        status: 200,\n        headers: new Headers({\n          'Cache-Control': 'private, no-cache, must-revalidate',\n        }),\n      };\n    } else if (errors.length === 1 && errors[0] instanceof HttpQueryError) {\n      response.http = {\n        status: errors[0].statusCode,\n        headers: new Headers(errors[0].headers),\n      };\n    }\n\n    return sendResponse(response);\n  }\n\n  function formatErrors(\n    errors: ReadonlyArray<GraphQLError>,\n  ): ReadonlyArray<GraphQLFormattedError> {\n    return formatApolloErrors(errors, {\n      formatter: config.formatError,\n      debug: requestContext.debug,\n    });\n  }\n\n  async function initializeRequestListenerDispatcher(): Promise<\n    Dispatcher<GraphQLRequestListener<TContext>>\n  > {\n    const requestListeners: GraphQLRequestListener<TContext>[] = [];\n    if (config.plugins) {\n      for (const plugin of config.plugins) {\n        if (!plugin.requestDidStart) continue;\n        const listener = await plugin.requestDidStart(requestContext);\n        if (listener) {\n          requestListeners.push(listener);\n        }\n      }\n    }\n    return new Dispatcher(requestListeners);\n  }\n\n  async function initializeDataSources() {\n    if (config.dataSources) {\n      const context = requestContext.context;\n\n      const dataSources = config.dataSources();\n\n      const initializers: any[] = [];\n      for (const dataSource of Object.values(dataSources)) {\n        if (dataSource.initialize) {\n          initializers.push(\n            dataSource.initialize({\n              context,\n              cache: requestContext.cache,\n            }),\n          );\n        }\n      }\n\n      await Promise.all(initializers);\n\n      if ('dataSources' in context) {\n        throw new Error(\n          'Please use the dataSources config option instead of putting dataSources on the context yourself.',\n        );\n      }\n\n      (context as any).dataSources = dataSources;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}